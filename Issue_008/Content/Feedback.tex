\chapter{Feedback on Issue 5}

While looking at something else, I noticed that in Issue 4, Page 28, Section 4.2.1 the following text:


\emph{For example, in many opcodes, the size of the operand - .B, .W or .L - is specified in bits 5 and 6 of the opcode instruction word in memory.This is therefore a 2 bit wide bit field, starting at bit $31-5=26$ and would be represented as follows:}

	\opcode{\{26:2\}}


I thought something was wrong, but didn't know which bit(!) was incorrect, so I worked through it and of course, the two bits in the bit field are wrong! The text should read as follows:

For example, in many opcodes, the size of the operand - .B, .W or .L - is specified in bits 6 and 5 of the opcode instruction word in memory.This is therefore a 2 bit wide bit field, starting at bit $31-6=25$ and would be represented as follows:

	\opcode{\{25:2\}}

I had of course specified a bit field for bits 5 and 4 and not for bits 6 and 5. I did mention that there was a certain amount of confusion in bit field specifications!


\chapter{Feedback on Issue 7}

Well now, here's a thing. Very quickly after Issue 7 "hit the streets" I got feedback from two different people. Thanks very much to Wolfgang and to Marcel for their input, and their permission to publish.


\section{Feedback from Wolfgang Lenerz}

[WL] Just a little comment: there is a typo on page 16, in the third code extract at line 1: Tobias makes a \opcode{MOVEM} to ...\register{a2-a7} : it should be to ...\register{a2-a6}.

[ND] Thanks. I don't have a Q68 (yet?) and I really didn't have much to do with Tobias's article to get it into the eComic, so I didn't notice that slight error. I fixed it in the PDF download on 1st October 2019 at around 19:00 BST (UTC + 01:00) - so anyone who downloaded prior to that time might wish to download again to get the correction.


[WL] Also a more general comment, which I offer as constructive criticism: in the  \texttt{utf82ql} routine, when handling values over 127 (i.e. at least 2 bytes), why check for the special cases first (arrows, pound etc) before getting the values from the table? Wouldn't it be better to leave their place in the table at 0 as well, and every time you hit a 0 in the table you check for the exception?

[ND] Good point, thanks. That would have made more sense as the processing is more likely to be processing valid characters than the exceptions. I thought I was doing well getting the exceptions in what I thought was the most likely order!


[WL] Oh, and this probably doesn't get said often enough : \emph{ really enjoy reading your prose!}

[ND] Thanks. It's nice to get feedback, but much nicer to get compliments. 



\section{Feedback from Marcel Kilgus}

[MK] As a pedantic ass I have to object so sentences like these:

\emph{The UK Pound symbol is character 96 (\$60) on the QL, but in ASCII
it is character 163 (\$A3)" (etc.)}

[ND] I like pedants! My wife says I am one, then she corrects me at every available opportunity!


[MK] ASCII is, by definition, 7-bit, so it cannot contain a character with
the number 163. The tale of characters 128-255 is one fought in many
battles. Linux tended to be "ISO 8859-1" and later "ISO 8859-15"
before they adopted UTF-8, on Windows you will mostly find the
"Windows-1252" encoding. These are very similar, but differ when it
comes to the Euro sign for example (ISO 8859-1 is too old to have a
Euro sign and the others have adopted it in different places).

[ND] Technically, I agree, ASCII is indeed 7 bit and 163 is definitely not 7 bit. But let's face it, there have been 8 bit "ASCII" characters for many years, even when I was at college back in the, ahem, early eighties, ASCII was (at least, considered) 8 bit - whether pedantically correct or not. However, true ASCII is 7 bit.

[ND] I remember many occasions, back when \url{config.txt} was still a thing, trying to set up the correct code page for a system. A nightmare as there was no Google back then to help out, just the manual for whatever system I was installing or working with.

[ND] I am led to understand, however, that ISO/IEC 4873 introduced some extra control codes ``characters'', in the \$80 to \$9F hexadecimal range, as part of extending the 7-bit ASCII encoding to become an 8-bit system.\footnote{The Unicode Consortium (October 27, 2006). "Chapter 13: Special Areas and Format Characters" (PDF). In Allen, Julie D. (ed.). The Unicode standard, Version 5.0. Upper Saddle River, New Jersey, US: Addison-Wesley Professional. p. 314. ISBN 978-0-321-48091-0. Retrieved March 13, 2015.} However, I sit corrected on the 7/8 bit point. Thanks.


[MK] But, and that is the important thing, Unicode was made to unify them
all. And UTF-8 is a pretty darn cool invention, unfortunately it came
too late for Windows, which was a very early adopter of Unicode at a
time when everybody thought "65536 characters ought to be enough for
everyone!". So Windows started to used 16-bits for every character
("UCS-2" encoding), which makes coding somewhat weird, and then they
found out that 65536 characters are not enough after all, so now
Windows uses UTF-16, which is UTF-8's big brother, with sometimes 2
bytes per character and sometimes 4. What a mess. But when it comes to
data storage UTF-8 is the way to go these days, always!

[ND] It sure is a mess, and yes, UTF-8 is the way to go. As I mentioned XML files depend on it, the web is pretty much full of it in all those HTML files etc. And, once you get your head around the difference between a ``code point'' and the character's actual bytes, it's pretty easy to understand.

[ND] I'm not so sure that Windows is missing out or behind the times though. At work, my files are all pretty much UTF-8 (I write my documents in  \texttt{ASCIIDOCTOR}\footnote{Now that's ironic!} format and convert them to PDF files using  \texttt{asciidoctor-pdf} - if I need Office flavoured docs, I use  \texttt{pandoc} to convert to something in DOCX format - but I almost never use those.  \texttt{Asciidoctor} files are plain text, and very easy to version control!  \texttt{Notepad++} or  \texttt{VSCodium} are my text editors of choice and both save in UTF-8 with no problems. Even Notepad itself can read the files - and I suspect Windows 10 will be better, I'm on Windows 7. (Currently)

[ND] Mind you, those damned so-called "smart" quotes that Office documents insist on using mess things up truly. It's the first thing I turn off with my Office stuff, and every slight update or patch seems to turn them back on! So annoying.

[MK] For QPC I already implemented these translations 20 years ago when
copying text to/from the clipboard. But well done for bringing UTF-8
to the QL 

[ND] Well, thanks for the reminder of how old I'm getting! The reason I did the utilities was simple, I had one of those itches to scratch. When I did a bit of work with Jan on his updated QL Monitor, I used a Linux system to do the typing - it's what I'm used to - and those arrow characters caused me no end of grief, as did the copyright and the pound signs. I messed about there using actual, ahem, ASCII codes (sorry!) but now, I don't have to.

[ND] Oh, and \emph{thank you} for  \texttt{QPC2}, it's my favourite QL program of all time, and it simply "just" works on Linux under  \texttt{Wine}. I did have some problems recently with it not working, but I traced that to a mix and match installation with bits of  \texttt{Wine 3} and bits of  \texttt{Wine 4} living together in sin. 

\texttt{QPC2} is what has kept me in the QL scene for as long as I can remember - I always got somewhat tired of the QL, the cables, the hard drive, the noise, the length of table I needed with limited space in my flat (apartment) and so on. With  \texttt{QPC2} it's all on my laptop. Nice and compact.

[ND] And, by the way, \emph{I am a pedant's baddest nightmare!}


\section{\emph{More} Feedback from Wolfgang Lenerz}


[WL] I had a longer look at ql2utf8. I hope you don't mind a few more comments.

[ND] No, I like getting comments - most people do assembly better than I do!

[WL] When I tried to compile the source file, I couldn't, as the different traps weren't defined.

\begin{lstlisting}[numbers=none]
io_fbyte        equ 1
io_sbyte        equ 5
mt_frjob        equ 5
\end{lstlisting}

[ND] Were you using \texttt{QMAC} by any chance? I know that's a recurring problem for \texttt{QMAC} as \texttt{GWASS} and \texttt{GWASL} come with the various traps and vectors "automatically" included. If I include them in the source, then they won't assemble for me, I get an error about duplicate definitions.


[WL] Moreover, I got a few errors that some bra.s  were out of reach.

[ND] Hmmm, I just recompiled with \texttt{GWASS} and got no errors at all. However, I did get one error with \texttt{GWASL}. Looking at the listing file, it's complaining that the label \texttt{oneByte} is an ``illegal instruction'' - weird. I remember \texttt{GWASL} doing that on a few occasions in the past. I used to edit the sources, rub out the label, and type it in again, that usually worked. I could never trace it to hidden characters etc as a hex dump of the source showed nothing out of the ordinary.

I don't however, get any errors about short branches being out of reach. 


[WL] It seems to me that the two lines of code at label \texttt{TestBit7} are superfluous: you are doing the exact same test just beneath it, at label \texttt{Testpound}.

[ND] That's a typing error. Originally I only had the BVS.S instruction rather than the BTST \#7 so in theory, if D1 was loaded with a byte >= \$80 the V flag would be set. Unfortunately it didn't work. I traced the code under QMON2 and by the time we get to that point, the V flag is clear, always. I obviously forgot to remove the BVS when I edited the code to add in the BTST \#7 instruction. My mistake.


[WL] You could replace the two instructions at Label \texttt{OneByte} with the single instruction \texttt{PEA readLoop}.

[ND] I see what you mean, if I do that replacement, then instead of branching to \texttt{writeByte} and returning and then branching off to \texttt{readLoop}, just drop in to \texttt{writeByte} and return automagically to the top of the loop. Nice!


[WL] Then you could also just delete the last two instructions of label \texttt{gotCopyright} (no need to bsr.s writebyte, you just fall through) and you could also replace, in the different \texttt{gotxxxx} routines (e.g. \texttt{gotEuro}, \texttt{gotGrave} etc) the two instructions:

\begin{lstlisting}[numbers=none]
 bsr.s writeByte
 bra readLoop
\end{lstlisting}
 
with a simple:

\begin{lstlisting}[numbers=none]
 bra.s oneByte
\end{lstlisting}
 
and it might be able to use a bra.s rather than a bra somewhere in the changed code.

[ND] Yes, that all makes perfect sense given the above changes to \texttt{oneByte}.

[WL] At label \texttt{notArrows}, you might want to replace these 4 lines

\begin{lstlisting}[numbers=none]
 addq.b  #1,d2
 move.b  0(a2,d2.w),d1   ; Second byte
 bsr     writeByte       ; Send it out
 bra     readLoop        ; Go around.
\end{lstlisting}

with these two

\begin{lstlisting}
 move.b  1(a2,d2.w),d1   ; Second byte
 bra     oneByte
\end{lstlisting}
 
[ND] Yes, that makes perfect sense too. Thanks.


[WL] I would set the output \& input channel IDs into two registers (eg A4, A5) and move them into A0 when needed in the byte read/write subroutines, instead of accessing the stack (and thus memory) every time with a LEA.

[ND] I used A4 and A5 for that very purpose in the following chapter, in the \texttt{Utf82ql} code, and forgot to go back and fix this code to do the same.

[WL] Finally, I would also include  test at label \texttt{notArrows} to make sure that the byte in D1 doesn't exceed the max value of your table. I know that values above that are not printable characters, but it \emph{is} possible to include them in a text file. You might want to tell the user that some characters couldn't be translated...

[ND] Yes indeed, that was an oversight. Thanks for pointing it out.

[WL] Hope you don't mind the above.

[ND] Not at all, many thanks indeed.

So, given all those amendments, here for your delectation is the latest version of the \texttt{Ql2utf8} code, incorporating all of Wolgang's changes and corrections.


\section{\emph{Even More} Feedback from Wolfgang Lenerz}
	
[WL] I also had a look through the \texttt{utf2ql} code. Some of the comments made for the other routine (\texttt{ql2utf8} ND) may also apply here, no need to go through them again. Here I have some more comments on this routine.

[ND] Ok, I'm sitting comfortably ....
	
[WL] The first one is not really about the code itself, but the way you structured it. Of course, this is much of a personal preference, so please take this with a pinch (or even a spoonful) of salt. Leaving out the exception and read/write routines, your code is structured thus:
	
\begin{lstlisting}[numbers=none]
  readLoop
    get byte
    leave if EOF

  Multibytes
    is it two bytes?
    yes -> jump to handle_two
  
  NotTwo
    is it three bytes?
    yes -> jump to handle_three

  Error   
    not three bytes, return error

  handle_two   
    treat two bytes
    bra    readloop

  handle_three
    treat three bytes
    bra    readLoop
\end{lstlisting}
	
	
[WL] For me, you have 6 different blocks of code. I would prefer the following structure with 4 blocks (making the code less "spaghetti"):
	
\begin{lstlisting}[numbers=none]	
  readLoop
    get byte
    leave if EOF

  handle_two
    is it two bytes?
    no-> jump to handle three
    treat two bytes
    bra    readloop

  handle_three
    is it 3 bytes?
    no -> jump to error
    treat three bytes
    bra    readLoop

  Error   
    not three bytes, return error
\end{lstlisting}

[ND] Yes, I admit that sometimes my structure leaves a lot to be desired and you are correct in what you say above - I must try harder!
	
	
[WL] Leaving out the branches to the loop, basically your way of doing it is:
	
\begin{lstlisting}[numbers=none]	
  is it something?
    yes, go off, handle it_1
  is it something else?
    yes, go off and handle it_2
  error
  handle_it1
  handle_it2
\end{lstlisting}
	
[WL] Whereas mine is:
	
\begin{lstlisting}[numbers=none]	
  is it something?
    no, go off to next check

  handle it1
    is it something else?
      no, go to error

  handle it2

  error
\end{lstlisting}
	
[WL] Again, this is a personal preference: There is no functional difference, but I, personally, find the second one easier to read if you want to follow the flow of the code.

[ND] Agreed.
	
[WL] But in doing so it will allow you to write the code at the \texttt{multiBytes} label so:
	
\begin{lstlisting}[numbers=none]	
  multiBytes
    move.b    d1,d2
    andi.b    #%11100000,d2    ; <-- BUG HERE? [ND]
    cmp.b     #%11000000,d2    ; 2 bytes?
    bne.s     threebytes       ;  ... no->

  twoBytes
    (treat 2 bytes including exceptions)

  testThree   (no need to copy d1 into d2 again)
    cmp.b     #%11100000,d2    ; 3 bytes?
    bne       invalidUTF8      ;  ... no ->
    ...
\end{lstlisting}
	
[ND] Hmm, I think you have a bug there. For three byte characters the top nibble should be 1110, so your mask is missing a '1' bit. I suspect you intended to type the following for \texttt{multiBytes}:

\begin{lstlisting}[numbers=none]	
  multiBytes
    move.b    d1,d2
    andi.b    #%11110000,d2
\end{lstlisting}

Otherwise you are forcing bit 4 of D2 to always be a zero. However, that minor niggle aside, I like your version better than mine as I/we only need a single ANDI instruction which keeps the top nibble, which can then be compared to check for two byte (110x) or three byte (1110) characters. Far more efficient indeed.

	
[WL] The \texttt{scanTable} routine is probably the most time consuming part of the code, so I'd have written it as follows:

\begin{lstlisting}[numbers=none]	
  scanTable
    move.l    a2,a3            ; point to table
    move.w    #59,d0           ; there are 60 words to compare

  scanLoop
    cmp.w     (a3)+,d2         ; is it a match?
    beq.s     scanDone         ;  ...yes ->
    dbf       d0,scanLoop      ; try all permitted values
    rts                        ; no match found, return NZ from cmp

  scanDone   
    move.l    a3,d0            ; where we found it (+2)
    sub.l     a2,d0            ; index into table
    subq.w    #2,d0            ; but we overshot by 2 bytes

    lsr.w     #1,d0            ; offset into index
    add.w     #$80,d0          ; convert to character code
    cmp.w     d0,d0            ; see below
    rts                        ; the condition code Z is set by the cmp
\end{lstlisting}

[ND] Curses, I've been found out! My way was easier for me as I didn't have to count up however many two byte characters there were! However, as they say about Unix/Linux, there's more than one way to skin a cat, but again, I prefer your method.
	
[WL] There are a few more instructions when you find the correct value, but the search loop itself is smaller and will be faster (unless the value searched for is the very first in the table, and even then it'll be a close match). The CMP D0,D0 is there so that the routine returns with the Z flag set, without affecting any other register by zeroing it. 

[ND] I wasn't fond of the non-standard way of detecting an error in my version, I have to admit. This is far far better.

[WL] So, coming back from calling the routine at label \texttt{doScan}, a simple BNE.S ERROR will do:
	
\begin{lstlisting}[numbers=none]	
  doScan   
    bsr.s    scanTable
    bne.s    invalidUTF8
    (... success in d0 ...)
\end{lstlisting}

[ND] Agreed, this is better and resembles more a standard error return, zero is good, non-zero is not good.

[WL] At label \texttt{twoBytes}, you should be able to write:

\begin{lstlisting}[numbers=none]
  twoBytes
    lsl.w    #8,d1             ; move byte up
    bsr      readByte          ; get next byte into LSB of D1
\end{lstlisting}
	
[WL] You should now have the correct word in D1. Remember, though, as of then to test on D1, not D2, for valid utf, even in the \texttt{scanTable} loop.

\textbf{Note}, this presumes that the trap handler does its work correctly and \emph{only} modifies the LSB\footnote{LSB = Lowest Significant Byte.} of D1 to put the returned value in there. (Unlike, e.g. some early versions of SMSQmulator which just reset the \emph{entire} register to 0 and then sets the byte. Ouch!)

[ND] I think that I shall leave the code using D2, just in case it causes problems elsewhere then. Better safe than sorry.
	
[WL] Most of these comments go a little beyond just checking the code itself, I hope you don't mind.

[ND] No, I don't mind and in fact I welcome comments on anything printed in this ePeriodical. If you have a problem with my writing style, code etc, I'm happy to hear from you. From anyone that is!

\section{A Better Ql2utf8}

\begin{lstlisting}[firstnumber=1, caption={Wolfgang's improved ql2utf8 Utility}]
;--------------------------------------------------------------------
; QL2UTF8:
;
; This filter converts QL text files to UTF8 for use on Linux, Mac or
; Windows where most modern editors etc, default to UTF8.
;
;
; EX ql2utf8_bin, input_file, output_file_or_channel
;
;--------------------------------------------------------------------
; 26/09/2019 NDunbar Created for QDOSMSQ Assembly Mailing List
; 07/10/2019 WLenerz Many improvements.
;--------------------------------------------------------------------
; (c) Norman Dunbar, Wolfgang Lenerz 2019. Permission granted for
; unlimited use or abuse, without attribution being required.
; Just enjoy!
;--------------------------------------------------------------------

; How many channels do I want?
numchans    equ     2         ; How many channels required?


; Stack stuff.
sourceId    equ     $02       ; Offset(A7) to input file id
destId      equ     $06       ; Offset(A7) to output file id

; Other Variables
pound       equ     96        ; UK Pound sign.
copyright   equ     127       ; (c) sign.
grave       equ     159       ; Backtick/Grave accent.
euro        equ     181       ; Euro symbol
err_bp      equ     -15       ; Bad parameter
err_eof     equ     -10       ; End of file
err_or      equ     -4        ; Out of range
me          equ     -1        ; This job's id
timeout     equ     -1        ; Infinty, and beyond!

;--------------------------------------------------------------------
; Uncomment the following if you are using QMAC as your assembler.
;--------------------------------------------------------------------
; io_fbyte    equ     1         ; Fetch one byte
; io_sbyte    equ     5         ; Send one byte
; mt_frjob    equ     5         ; Force remove a job
;--------------------------------------------------------------------

;====================================================================
; Here begins the code.
;--------------------------------------------------------------------
; Stack on entry:
;
; $06(a7) = Output file channel id.
; $02(a7) = Source file channel id.
; $00(a7) = How many channels? Should be $02.
;====================================================================
start
    bra.s   checkStack

    dc.l    $00
    dc.w    $4afb
name
    dc.w    name_end-name-2
    dc.b    'QL2UTF8'
name_end    equ     *

version     dc.w    vers_end-version-2
            dc.b    'Version 1.01'
vers_end    equ      *


bad_parameter
    moveq   #err_bp,d0        ; Guess!
    bra     errorExit         ; Die horribly


;--------------------------------------------------------------------
; Check the stack on entry. We only require NUMCHAN channels - any
; thing other than NUMCHANS will result in a BAD PARAMETER error on
; exit from EW (but not from EX).
;--------------------------------------------------------------------
checkStack
    cmpi.w  #numchans,(a7)    ; Two channels is a must
    bne.s   bad_parameter     ; Oops

;--------------------------------------------------------------------
; Initialise a couple of registers that will keep their values all
; through the rest of the code.
;--------------------------------------------------------------------
ql2utf8
    lea     utf8,a2           ; Preserved throughout
    moveq   #timeout,d3       ; Timeout, also Preserved
    move.l  sourceID(a7),a4   ; Input channel id
    move.l  destId(a7),a5     ; Output channel id

;--------------------------------------------------------------------
; The main loop starts here. Read a single byte, check for EOF etc.
;--------------------------------------------------------------------
readLoop
    moveq   #io_fbyte,d0      ; Fetch one byte
    move.l  a4,a0             ; Channel to readLoop
    trap    #3                ; Do input
    tst.l   d0                ; OK?
    beq.s   testBit7          ; Yes
    cmpi.l  #err_eof,d0       ; All done?
    beq     allDone           ; Yes.
    bra     errorExit         ; Oops!

testBit7
    btst    #7,d1             ; Bit 7 set?
    bne.s   twoBytes          ; Multi Byte character if so

;--------------------------------------------------------------------
; The UK Pound and copyright signs are exceptions to the "bytes 
; less than $80 are the same in UTF8 as they are in ASCII" rule as 
; Sir Clive didn't follow ASCII 100%. Both characters are multi-byte
; in UTF8.
;--------------------------------------------------------------------
testPound
    cmpi.b  #pound,d1         ; Got a UK Pound sign?
    bne.s   testCopyright     ; No.

gotPound
    move.b  #$c2,d1           ; Pound is $C2A3 in UTF8.
    bsr.s   writeByte         ; Write first byte
    move.b  #$a3,d1
    bra.s   oneByte           ; Write out & carry on.

;--------------------------------------------------------------------
; Here we repeat the same check as above, in case we have the
; copyright sign.
;--------------------------------------------------------------------
testCopyright
    cmpi.b  #copyright,d1     ; Got a copyright sign?
    bne.s   oneByte           ; No.

gotCopyright
    move.b  #$c2,d1           ; Copyright is $C2A9 in UTF8
    bsr.s   writeByte         ; Write first byte
    move.b  #$a9,d1           ; Then drop in to write & carry on

;--------------------------------------------------------------------
; All other ASCII characters, below $80, are single byte in UTF8 and
; are the same code as in ASCII. Stack the address of readLoop and
; drop into writeByte. On RTS, we will hit the top of the loop again.
; (Courtesy Wolfgang Lenerz.)
;--------------------------------------------------------------------
oneByte     
    pea     readLoop

;--------------------------------------------------------------------
; A small but perfectly formed subroutine to send the byte in D1 to
; the output channel.
;--------------------------------------------------------------------
writeByte
    moveq   #io_sbyte,d0      ; Send one byte
    move.l  a5,a0             ; Output channel id
    trap    #3
    tst.l   d0                ; OK?
    bne     errorExit         ; Oops!
    rts

;--------------------------------------------------------------------
; ASCII codes from $80 upwards require multiple bytes in UTF8. In the
; case of the QL, these are mostly 2 bytes long. I could use IO_SSTRG
; here, I know. 
; However, as ever, there are exceptions. The grave accent (backtick)
; is a single byte on output, while the 4 arrow keys are three bytes.
; The bytes to be sent are read from a table because, again, the QL
; is not using the full set of accented characters - so there is
; mucking about to be done.
;--------------------------------------------------------------------
twoBytes
    cmpi.b  #grave,d1         ; Backtick/Grave accent?
    bne.s   testEuro          ; No.

;--------------------------------------------------------------------
; We are dealing with a backtick character (aka Grave accent)?
;--------------------------------------------------------------------
gotGrave
    move.b  #pound,d1         ; Grave in = pound out!
    bra.s   oneByte           ; Write out & carry on

;--------------------------------------------------------------------
; Here we repeat the same check as above, in case we have the
; Euro sign.
;--------------------------------------------------------------------
testEuro
    cmpi.b  #euro,d1          ; Got a Euro sign?
    bne.s   testArrows        ; No.

gotEuro
    move.b  #$e2,d1           ; Euro is $E282AC in UTF8
    bsr.s   writeByte         ; Write first byte
    move.b  #$82,d1
    bsr.s   writeByte         ; Write second byte
    move.b  #$ac,d1
    bra.s   oneByte           ; Write out and carry on

;--------------------------------------------------------------------
; The arrows are $BC, $BD, $BE and $BF (left, right, up, down). These
; are three bytes in UTF8, $E2 $86 $9x where 'x' is 0, 2, 1 or 3.
;--------------------------------------------------------------------
testArrows
    move.b  d1,d2             ; Copy character code
    subi.b  #$bc,d2           ; Anything lower = C set
    bcs.s   notArrows         ; And is not an arrow
    subq.b  #4,d2             ; Arrows = 0-3. C clear is bad
    bcc.s   notArrows         ; Still not an arrow.

gotArrows
    subi.b  #$bc,d1           ; Correct arrow code, 0 - 3
    lea     arrows,a3         ; Arrow table
    move.b  d1,d2             ; Save index into table
    ext.w   d2                ; Need word not byte

    move.b  #$e2,d1           ; First byte
    bsr.s   writeByte
    move.b  #$86,d1           ; Second byte
    bsr.s   writeByte
    move.b  0(a3,d2.w),d1     ; Third byte
    bra.s   oneByte           ; Write it & go around again.

;--------------------------------------------------------------------
; We need this as arrows in the QL are Left, Right, Up, Down but in
; UTF8 they are Left, Up, Right, Down. Sigh.
;--------------------------------------------------------------------
arrows
    dc.b    $90,$92,$91,$93   ; Awkward byte order!

;--------------------------------------------------------------------
; Now we are certain, everything is two bytes. Read them from the
; table and write them out. However, there are only 60 entries in the
; table - best we check!
;--------------------------------------------------------------------
notArrows
    cmpi.b  #59,d1            ; Are we in range for the table?
    bcc.s   inRange           ; Yes

outOfRange
    moveq   #err_or,d0        ; Out of range
    bra.s   errorExit         ; Oops!

inRange
    move.b  d1,d2             ; D2 = byte just read
    subi.b  #$80,d2           ; Adjust for table index
    ext.w   d2                ; Word size needed
    lsl.w   #1,d2             ; Double D2 for Offset
    move.b  0(a2,d2.w),d1     ; First byte
    bsr.s   writeByte         ; Send it output
    move.b  1(a2,d2.w),d1     ; Second byte
    bra     oneByte           ; Write it and go around


;--------------------------------------------------------------------
; No errors, exit quietly back to SuperBASIC.
;--------------------------------------------------------------------
allDone
    moveq   #0,d0

;--------------------------------------------------------------------
; We have hit an error so we copy the code to D3 then exit via a
; forcible removal of this job. EXEC_W/EW will display the error in
; SuperBASIC, but EXEC/EX will not.
;--------------------------------------------------------------------
errorExit
    move.l  d0,d3             ; Error code we want to return

;--------------------------------------------------------------------
; Kill myself when an error was detected, or at EOF.
;--------------------------------------------------------------------
suicide
    moveq   #mt_frjob,d0      ; This job will die soon
    moveq   #me,d1
    trap    #1

;--------------------------------------------------------------------
; The following table contains the two byte sequences required for 
; QL characters above $80. These are all 2 bytes in UTF8, so quite a 
; simple case. (Not when converting UTF8 to QL though!) There are 60
; QL characters which convert to two byte UTF8 characters.
;--------------------------------------------------------------------
utf8
    dc.w    $c3a4             ; a umlaut
    dc.w    $c3a3             ; a tilde
    dc.w    $c3a2             ; a circumflex
    dc.w    $c3a9             ; e acute
    dc.w    $c3b6             ; o umlaut
    dc.w    $c3b5             ; o tilde
    dc.w    $c3b8             ; o slash
    dc.w    $c3bc             ; u umlaut
    dc.w    $c3a7             ; c cedilla
    dc.w    $c3b1             ; n tilde
    dc.w    $c3a6             ; ae ligature
    dc.w    $c593             ; oe ligature
    dc.w    $c3a1             ; a acute
    dc.w    $c3a0             ; a grave
    dc.w    $c3a2             ; a circumflex
    dc.w    $c3ab             ; e umlaut
    dc.w    $c3a8             ; e grave
    dc.w    $c3aa             ; e circumflex
    dc.w    $c3af             ; i umlaut
    dc.w    $c3ad             ; i acute
    dc.w    $c3ac             ; i grave
    dc.w    $c3ae             ; i circumflex
    dc.w    $c3b3             ; o acute
    dc.w    $c3b2             ; o grave
    dc.w    $c3b4             ; o circumflex
    dc.w    $c3ba             ; u acute
    dc.w    $c3b9             ; u grave
    dc.w    $c3bb             ; u circumflex
    dc.w    $ceb2             ; B as in ss (German)
    dc.w    $c2a2             ; Cent
    dc.w    $c2a5             ; Yen
    dc.w    $0000             ; Grave accent - single byte
    dc.w    $c384             ; A umlaut
    dc.w    $c383             ; A tilde
    dc.w    $c385             ; A circle
    dc.w    $c389             ; E acute
    dc.w    $c396             ; O umlaut
    dc.w    $c395             ; O tilde
    dc.w    $c398             ; O slash
    dc.w    $c39c             ; U umlaut
    dc.w    $c387             ; C cedilla
    dc.w    $c391             ; N tilde
    dc.w    $c386             ; AE ligature
    dc.w    $c592             ; OE ligature
    dc.w    $ceb1             ; alpha
    dc.w    $ceb4             ; delta
    dc.w    $ceb8             ; theta
    dc.w    $cebb             ; lambda
    dc.w    $c2b5             ; micro (mu?)
    dc.w    $cf80             ; PI
    dc.w    $cf95             ; o pipe
    dc.w    $c2a1             ; ! upside down
    dc.w    $c2bf             ; ? upside down
    dc.w    $0000             ; Euro
    dc.w    $c2a7             ; Section mark
    dc.w    $c2a4             ; Currency symbol
    dc.w    $c2ab             ; <<
    dc.w    $c2bb             ; >>
    dc.w    $c2ba             ; Degree
    dc.w    $c3b7             ; Divide
\end{lstlisting}


\section{A Better Utf82ql}

\begin{lstlisting}[firstnumber=1, caption={Wolfgang's improved utf82ql Utility}]
;--------------------------------------------------------------------
; UTF82QL:
;
; This filter converts UTF8 text files from Linux, Mac or Windows to
; to the SMSQ character set.
;
;
; EX utf82ql2_bin, input_file, output_file_or_channel
;
;--------------------------------------------------------------------
; 28/09/2019 NDunbar Created for QDOSMSQ Assembly Mailing List.
; 07/10/2019 WLenerz Many improvents.
;--------------------------------------------------------------------
; (c) Norman Dunbar, Wolfgang Lenerz, 2019. Permission granted for
; unlimited use or abuse, without attribution being required.
; Just enjoy!
;--------------------------------------------------------------------

; How many channels do I want?
numchans    equ     2       ; How many channels required?


; Stack stuff.
sourceId    equ     $02     ; Offset(A7) to input file id
destId      equ     $06     ; Offset(A7) to output file id

; Other Variables
utf8Pound   equ     $c2a3   ; UTF8 Pound sign
qlPound     equ     96      ; QL Pound sign

utf8Grave   equ     96      ; UTF8 Grave code
qlGrave     equ     159     ; QL Grave code

utf8Copyright equ   $c2a9   ; UTF8 copyright
qlCopyright equ     127     ; QL copyright sign

qlEuro      equ     181     ; SMSQ Euro symbol

err_exp     equ     -17
err_bp      equ     -15
err_eof     equ     -10
err_or      equ     -4
me          equ     -1
timeout     equ     -1

;--------------------------------------------------------------------
; Uncomment the following if you are using QMAC as your assembler.
;--------------------------------------------------------------------
; io_fbyte    equ     1       ; Fetch one byte
; io_sbyte    equ     5       ; Send one byte
; mt_frjob    equ     5       ; Force remove jobs
;--------------------------------------------------------------------


;====================================================================
; Here begins the code.
;--------------------------------------------------------------------
; Stack on entry:
;
; $06(a7) = Output file channel id.
; $02(a7) = Source file channel id.
; $00(a7) = How many channels? Should be $02.
;====================================================================
start       bra.s   checkStack

            dc.l    $00
            dc.w    $4afb
name        dc.w    name_end-name-2
            dc.b    'UTF82QL'
name_end    equ     *

version     dc.w    vers_end-version-2
            dc.b    'Version 1.00'
vers_end    equ     *


bad_parameter
    moveq   #err_bp,d0      ; Guess!
    bra     errorExit       ; Die horribly


;--------------------------------------------------------------------
; Check the stack on entry. We only require NUMCHAN channels - any
; thing other than NUMCHANS will result in a BAD PARAMETER error on
; exit from EW (but not from EX).
;--------------------------------------------------------------------
checkStack
    cmpi.w  #numchans,(a7)  ; Two channels is a must
    bne.s   bad_parameter   ; Oops

;--------------------------------------------------------------------
; Initialise a couple of registers that will keep their values all
; through the rest of the code.
;--------------------------------------------------------------------
ql2utf8
    lea     utf8,a2         ; Preserved throughout
    moveq   #timeout,d3     ; Timeout, also Preserved
    move.l  sourceId(a7),a4 ; Channel ID for UTF8 input file
    move.l  destId(a7),a5   ; Channel ID for QL output file

;--------------------------------------------------------------------
; The main loop starts here. Read a single byte, check for EOF etc.
;--------------------------------------------------------------------
readLoop
    bsr     readByte        ; Read one byte
    beq.s   testBit7        ; No errors is good.
    cmpi.l  #err_eof,d0     ; All done?
    beq     allDone         ; Yes.
    bra     errorExit       ; Oops!

;--------------------------------------------------------------------
; Test the top bit here. If it is zero, we are good for most single
; byte characters, otherwise it is potentially multi-byte. 
;--------------------------------------------------------------------
testBit7
    btst    #7,d1           ; Bit 7 set?
    bne.s   multiBytes      ; Multi Byte character if so

;--------------------------------------------------------------------
; In UTF8, the Grave accent (backtick) is a single byte character but
; the byte value doesn't correspond to that on the QL. On UTF8 it is
; $60 (96) but on the QL it is $9F (159) so, this is another Sir
; Clive induced exception!
;--------------------------------------------------------------------
testGrave
    cmpi.b  #utf8Grave,d1   ; Got a grave!
    bne.s   oneByte         ; Must be a single byte if not a pound.

gotGrave
    move.b  #qlGrave,d1     ; Write a grave character

;--------------------------------------------------------------------
; The byte read is a valid single byte character so it has the exact
; same code in the QL's variation of ASCII, just write it out.
;--------------------------------------------------------------------
oneByte
    bsr     writeByte       ; Write the byte out
    bra.s   readLoop        ; And continue.


;--------------------------------------------------------------------
; Most of the remaining characters will be two bytes in UTF8 and one
; byte on the QL. There are a few exceptions though - the Euro and 
; the four arrow keys are three bytes long in UTF8.
;--------------------------------------------------------------------
multiBytes
    move.b  d1,d2           ; Copy character code
    andi.b  #%11110000,d2   ; Keep top four bits
    cmpi.b  #%11000000,d2   ; Two bytes?
    bne.s   testThree       ; Yes.

;--------------------------------------------------------------------
; At this point we should have a UTF8 two byte character but we only
; have the first byte in D1. We need the second byte also, so read it
; and check that it is indeed valid.
;--------------------------------------------------------------------
twoBytes
    move.b  d1,d2           ; Save the leading byte
    bsr     readByte        ; Read the second byte
    lsl.w   #8,d2           ; Shift first byte upwards
    or.b    d1,d2           ; And add the new byte

;--------------------------------------------------------------------
; Exception checking. UTF8 codes $C2A3 for the UK Pound and $C2A9 for
; copyright, are not in the table. They are QL codes $60 (96) and $7F
; (127) and are exceptions to the rule that a QL code less than 128
; always has a one byte code in UTF8 - they are both two bytes.
;--------------------------------------------------------------------
testPound
    cmpi.w  #utf8Pound,d2   ; Got a UK Pound?
    bne.s   testCopyright   ; No

gotPound
    move.b  #qlPound,d1     ; QL Pound code
    bra.s   oneByte         ; Write it out & loop around

testCopyright
    cmpi.w  #utf8Copyright,d2 ; Got a copyright?
    bne.s   doScan          ; No

gotCopyright
    move.b  #qlCopyright,d1
    bra.s   oneByte         ; Write it out & loop around

;--------------------------------------------------------------------
; Ok, exceptions processed, do the remaining two byte characters.
;--------------------------------------------------------------------
doScan
    bsr     scanTable       ; Is this valid UTF8?
    bne.s   invalidUTF8     ; Nope

validUTF8
    move.b  d0,d1           ; Get the character code
    bsr.s   writeByte       ; Write it out
    bra     readLoop        ; And continue.

invalidUTF8
    moveq   #err_exp,d0     ; Error in expression
    bra     errorExit       ; Bale out.

;--------------------------------------------------------------------
; We are interested in a few three byte characters, so we check those
; next. These are identified by the top nibble of the first character
; read in being 1110.
;--------------------------------------------------------------------
testThree
    cmpi.b  #%11100000,d2   ; Three bytes?
    bne.s   invalidUTF8     ; No.

;--------------------------------------------------------------------
; At this point we should have a UTF8 three byte character but we 
; only have the first byte in D1. We need the second byte also, so 
; read it and check that it is indeed valid. Then get the third byte.
; All our three byte characters should have $E2 in the first byte.
;
; The Euro is $E282AC.
; The Arrows are $E2869x where 'x' is 0,1,2 or 3.
;--------------------------------------------------------------------
threeBytes
    cmpi.b  #$e2,d1         ; Valid three byte?
    bne.s invalidUTF8       ; Looks unlikely.

    move.b  d1,d2           ; Save the first byte
    bsr.s   readByte        ; Get the second byte
    cmpi.b  #$82,d1         ; Euro second byte?
    beq.s   threeValid       ; Yes
    cmpi.b  #$86,d1         ; Arrow second byte?
    bne.s   invalidUTF8     ; Sadly, no, error out.

threeValid
    lsl.w   #8,d2           ; Shift first byte upwards
    or.b    d1,d2           ; And add the new byte
    bsr.s   readByte        ; Get the third byte
    cmpi.w  #$e282,d2       ; Euro possibly?
    bne.s   threeArrows     ; No, try arrows
     
;--------------------------------------------------------------------
; We have read $e282 so if we get $ac next, we have the euro. If not
; it's an error in the UTF8 characters that the QL understands.
;--------------------------------------------------------------------
threeEuro
    cmpi.b  #$ac,d1         ; Need this for the Euro
    bne.s   invalidUTF8     ; No, error out again.
    move.b  #qlEuro,d1      ; QL Euro code
    bsr.s   writeByte       ; Write it out
    bra     readLoop        ; And continue.


;--------------------------------------------------------------------
; The QL arrows are $BC, $BD, $BE and $BF (left, right, up, down). 
; The UTF8, $E2869x where 'x' is 0, 2, 1 or 3 to correspond with the
; order of the QL arrow codes.
;--------------------------------------------------------------------
threeArrows
    cmpi.w  #$e286,d2       ; Got a potential arrow code?
    bne.s   invalidUTF8     ; Fraid not, error out.
    subi.b  #$90,d1         ; D1 is now 0-3 for valid arrows
    bmi.s   invalidUTF8     ; Oops, it went negative
    cmpi.b  #3,d1           ; Highest arrow code
    bhi.s   invalidUTF8     ; Oops, invalid arrow code.
    addi.b  #$bc,d1         ; Convert to QL arrow code.
    bsr.s   writeByte       ; Write it out
    bra     readLoop        ; And continue.
    

;--------------------------------------------------------------------
; A small but perfectly formed subroutine to send the byte in D1 to
; the output QL file. 
; On Entry, A0 = input channel ID and A3 = output channel ID. 
; On exit, D0 = 0, Z set.
; On error, never returns.
;--------------------------------------------------------------------
writeByte
    move.l  a5,a0           ; Get the correct channel ID
    moveq   #io_sbyte,d0    ; Send one byte
    trap    #3
    tst.l   d0              ; OK?
    bne.s   errorExit       ; Oops!
    rts

;--------------------------------------------------------------------
; Another perfectly formed subroutine to read one byte into D1
; from the input UTF8 file. 
; On Entry, A0 = output channel ID and A3 = input channel ID.
; On exit, error codes in D0, Z set if no error and D1.B = character
; just read.
;--------------------------------------------------------------------
readByte
    move.l  a4,a0           ; Get the correct channel ID
    moveq   #io_fbyte,d0    ; Fetch one byte
    trap    #3              ; Do input
    tst.l   d0              ; OK?
    rts
    
;--------------------------------------------------------------------
; Scan the UTF8 table looking for the word in D2. If found, we have
; the table offset in D0 and that is then halved to get the index which
; is still $80 below the correct character code - we add to convert.
; Returns with D0 = the character code, or $FFFF to show the end was
; reached and we appear to have an invalid two byte character. A2
; holds the table address. D7 is a working register.
;--------------------------------------------------------------------
scanTable
    move.l  a2,a3           ; Get start of table
    move.w  #59,d0          ; There are 60 entries in the table

scanLoop
    cmp.w   (a3)+,d2        ; Found it yet?
    beq.s   scanDone        ; Yes
    dbf     d0,scanLoop     ; No, try again
    rts                     ; Not found, Z not set.

scanDone
    move.l  a3,d0           ; Address in table + 2
    sub.l   a2,d0           ; Address now the Offset + 2
    subq.w  #2,d0           ; Adjusted to correct offset
    lsr.w   #1,d0           ; Conver to index
    add.w   #$80,d0         ; Now correct character code
    cmp.w   d0,d0           ; Sets Z flag
    rts

;--------------------------------------------------------------------
; No errors, exit quietly back to SuperBASIC.
;--------------------------------------------------------------------
allDone
    moveq   #0,d0

;--------------------------------------------------------------------
; We have hit an error so we copy the code to D3 then exit via a
; forcible removal of this job. EXEC_W/EW will display the error in
; SuperBASIC, but EXEC/EX will not.
;--------------------------------------------------------------------
errorExit
    move.l  d0,d3           ; Error code we want to return

;--------------------------------------------------------------------
; Kill myself when an error was detected, or at EOF.
;--------------------------------------------------------------------
suicide
    moveq   #mt_frjob,d0    ; This job will die soon
    moveq   #me,d1
    trap    #1

;--------------------------------------------------------------------
; The following table contains the two byte sequences required for 
; QL characters from character $80 onwards. Those flagged as $FFFF 
; are exceptions, dealt with in the code. There are no entries for
; the arrow keys as they would simply be zero words at the end of the
; table.
;--------------------------------------------------------------------
utf8
    dc.w    $c3a4           ; a umlaut
    dc.w    $c3a3           ; a tilde
    dc.w    $c3a2           ; a circumflex
    dc.w    $c3a9           ; e acute
    dc.w    $c3b6           ; o umlaut
    dc.w    $c3b5           ; o tilde
    dc.w    $c3b8           ; o slash
    dc.w    $c3bc           ; u umlaut
    dc.w    $c3a7           ; c cedilla
    dc.w    $c3b1           ; n tilde
    dc.w    $c3a6           ; ae ligature
    dc.w    $c593           ; oe ligature
    dc.w    $c3a1           ; a acute
    dc.w    $c3a0           ; a grave
    dc.w    $c3a2           ; a circumflex
    dc.w    $c3ab           ; e umlaut
    dc.w    $c3a8           ; e grave
    dc.w    $c3aa           ; e circumflex
    dc.w    $c3af           ; i umlaut
    dc.w    $c3ad           ; i acute
    dc.w    $c3ac           ; i grave
    dc.w    $c3ae           ; i circumflex
    dc.w    $c3b3           ; o acute
    dc.w    $c3b2           ; o grave
    dc.w    $c3b4           ; o circumflex
    dc.w    $c3ba           ; u acute
    dc.w    $c3b9           ; u grave
    dc.w    $c3bb           ; u circumflex
    dc.w    $ceb2           ; B as in ss (German)
    dc.w    $c2a2           ; Cent
    dc.w    $c2a5           ; Yen
    dc.w    $ffff           ; Grave accent - single byte
    dc.w    $c384           ; A umlaut
    dc.w    $c383           ; A tilde
    dc.w    $c385           ; A circle
    dc.w    $c389           ; E acute
    dc.w    $c396           ; O umlaut
    dc.w    $c395           ; O tilde
    dc.w    $c398           ; O slash
    dc.w    $c39c           ; U umlaut
    dc.w    $c387           ; C cedilla
    dc.w    $c391           ; N tilde
    dc.w    $c386           ; AE ligature
    dc.w    $c592           ; OE ligature
    dc.w    $ceb1           ; alpha
    dc.w    $ceb4           ; delta
    dc.w    $ceb8           ; theta
    dc.w    $cebb           ; lambda
    dc.w    $c2b5           ; micro (mu?)
    dc.w    $cf80           ; PI
    dc.w    $cf95           ; o pipe
    dc.w    $c2a1           ; ! upside down
    dc.w    $c2bf           ; ? upside down
    dc.w    $ffff           ; Euro
    dc.w    $c2a7           ; Section mark
    dc.w    $c2a4           ; Currency symbol
    dc.w    $c2ab           ; <<
    dc.w    $c2bb           ; >>
    dc.w    $c2ba           ; Degree
    dc.w    $c3b7           ; Divide

    dc.w    $0000           ; End of table
\end{lstlisting}
