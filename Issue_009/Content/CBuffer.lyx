#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
% Required for the setup of the listings.
\usepackage{xcolor}
\definecolor{ocre}{RGB}{243,102,25}
\definecolor{wwwDarkGreen}{HTML}{006400}
\definecolor{wwwDarkOrchid}{HTML}{9932CC}
\definecolor{wwwDarkOrange}{HTML}{FF8C00}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "PlatformIO for the Arduino User"
\pdf_author "Norman Dunbar"
\pdf_subject "PlatformIO"
\pdf_keywords "PlatformIO Arduino AVR ATMEGA ATMEGA328"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #ff557f
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "backgroundcolor={\color{ocre!10}},basicstyle={\small},breakatwhitespace=false,breaklines=false,captionpos=b,commentstyle={\color{wwwDarkGreen}},deletekeywords={...},escapeinside={\%*}{*)},extendedchars=true,frame=leftline,framerule=4pt,keepspaces=true,keywordstyle={\color{blue}},morekeywords={*,...},numbers=left,numbersep=10pt,numberstyle={\color{ocre}},rulecolor={\color{ocre}},showspaces=false,showstringspaces=false,showtabs=false,stepnumber=1,stringstyle={\color{wwwDarkOrange}},tabsize=2,title={\lstname},breaklines=true,postbreak={\mbox{\textcolor{ocre}{\textbf{$\Longrightarrow$}}\space}},language={[Motorola68k]Assembler}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Circular Buffers
\end_layout

\begin_layout Standard
A circular buffer is a device whereby data are written to it in order and
 removed from it in the same order – it's a 
\emph on
First In, First Out
\emph default
 queue, or FIFO, in other words.
 It is named 
\emph on
circular
\emph default
 because when data are written to the last location, the next byte stored
 will be at the beginning – as if the two ends of the buffer are joined
 together in, well, a circle! Wikipedia has a good description at 
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Circular_buffer"

\end_inset

 if you wish to read further.
\end_layout

\begin_layout Standard
I had to learn about them when writing an interrupt driven USART module
 for my Arduinos.
 The application code can write data to the buffer, and as long as it doesn't
 get full, the USART code can be pulling data out of the same buffer and
 sending it out onto the serial interface pins.
 Is this useful for the QL I hear you think? Who knows, but I thought it
 would be an interesting exercise to convert from C++ to Assembly Language,
 just for fun
\begin_inset Foot
status open

\begin_layout Plain Layout
For certain values of 
\begin_inset Quotes eld
\end_inset

fun
\begin_inset Quotes erd
\end_inset

 perhaps!
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The plan is, that a buffer can be allocated at a certain size, and then
 used and abused as required.
 As the code is required to use the Modulus operator to ensure that various
 calculations wrap around properly, the only restrictions of these buffers
 are:
\end_layout

\begin_layout Itemize
The size requested must be a power of two;
\end_layout

\begin_layout Itemize
The size requested must be a minimum of 2 bytes;
\end_layout

\begin_layout Itemize
The size requested must be a maximum of 32768 bytes;
\end_layout

\begin_layout Standard
Other than that, the sky is the limit!
\end_layout

\begin_layout Section
How Big is my Buffer?
\end_layout

\begin_layout Standard
You might think that a buffer is as big as requested? Assuming the request
 was for a valid power of two in size of course.
 A foible of circular buffers of this format is that they always end up
 losing a single byte of storage.
 Why is this?
\end_layout

\begin_layout Standard
Imagine a brand new empty buffer, let's say it's only two bytes in size
\begin_inset Foot
status open

\begin_layout Plain Layout
Because that means I have less typing to do in explaining it!
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
As the buffer has just been allocated, 
\begin_inset Formula $head=tail=0$
\end_inset

 and the buffer is officially empty.
 Nothing has been written to the buffer and nothing is available to be read.
 So far so good!
\end_layout

\begin_layout Standard
The application wants to write a byte to the buffer, so:
\end_layout

\begin_layout Itemize
Increment the head offset by 1.
 
\begin_inset Formula $Head=1$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Head\ MOD\ 2$
\end_inset

, which is required to account for any wrap around, leaves 
\begin_inset Formula $Head=1$
\end_inset

.
\end_layout

\begin_layout Itemize
Compare with the tail offset, 0.
 They are different, so the buffer has space available.
\end_layout

\begin_layout Itemize
Store the data byte at offset 1.
\end_layout

\begin_layout Itemize
Update the head offset in the buffer header.
\end_layout

\begin_layout Standard
This executes successfully and on return, 
\begin_inset Formula $head=1$
\end_inset

 and 
\begin_inset Formula $tail=0$
\end_inset

.
 The buffer has one byte in the data area.
 As you can see, the head pointer was incremented before storing the data
 byte and the new byte stored at that location.
 This means that currently, byte zero in the data area has been skipped
 over.
 Bear this in mind.
\end_layout

\begin_layout Standard
The application now wants to write a second byte to the buffer.
 The execution of this proceeds as follows:
\end_layout

\begin_layout Itemize
Increment the head offset by 1.
 
\begin_inset Formula $Head=2$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Head\ MOD\ 2$
\end_inset

, leaves 
\begin_inset Formula $Head=0$
\end_inset


\end_layout

\begin_layout Itemize
Compare with the tail offset, 0.
 They are equal, so the buffer has no space available!
\end_layout

\begin_layout Itemize
The second byte cannot be stored in the buffer!
\end_layout

\begin_layout Standard
So, we allocated a two byte buffer by can only store a single byte in it.
 There are other buffer structures which store the count of data bytes written
 and adjust this on each read or write, these buffers have the full compliment
 of space available for the overhead of a bit of extra processing.
\end_layout

\begin_layout Standard
Ok, why are we comparing the incremented head offset with the unincremented
 tail offset? If we didn't, then the test would have to be whether the two
 offsets were equal, which means we can't tell if the buffer is empty or
 full.
\end_layout

\begin_layout Section
Buffer Structure
\end_layout

\begin_layout Standard
The buffer is allocated as a chunk of memory where the size asked for by
 the user must be a power of two with a maximum size of 32,768 bytes which
 happens to be the largest power that fits into a word.
 Why a word? The buffer is made up of two parts, the data area of the requested
 size and a 6 byte header added to the front of the data area.
 The header is used to hold information about the buffer – its size plus
 the 
\emph on
head
\emph default
 and 
\emph on
tail
\emph default
 offsets into the data area – and these are word sized.
\end_layout

\begin_layout Standard
The 6 byte header stores the following information about the buffer:
\end_layout

\begin_layout Itemize
The data size.
 This is the actual size of the data area allocated for the buffer and does
 not include the 6 bytes added for the header.
\end_layout

\begin_layout Itemize
The head offset.
 This defines the offset into the data area where the most recent byte was
 
\emph on
written
\emph default
 to the buffer.
 The head will be adjusted to the next offset when a new byte is to be added
 to the buffer.
\end_layout

\begin_layout Itemize
The tail offset.
 This defines the offset into the data area where the most recent byte was
 
\emph on
read
\emph default
 from the buffer.
 The tail will be adjusted to locate the next offset, when the next request
 for a byte is processed.
\end_layout

\begin_layout Standard
The structure of our circular buffers will be as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Circular-Buffer-structure"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="55text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cbSize
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cbHead
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cbTail
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cbData
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Circular Buffer structure
\begin_inset CommandInset label
LatexCommand label
name "fig:Circular-Buffer-structure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can see the simplicity of the whole thing, it's just the data area with
 the afore mentioned 6 byte header.
\end_layout

\begin_layout Section
The Buffer Handling Code
\end_layout

\begin_layout Standard
The code functions we will create for this article will expect a buffer
 address to be passed in 
\family typewriter
A3.L
\family default
 and it is required that the address pointed top by 
\family typewriter
A3.L
\family default
 is that of the 
\family typewriter
cbSize
\family default
 field in the buffer.
 The start address in other words.
 However, as the initialisation of each function will retrieve the fields
 required from the buffer header, 
\family typewriter
A3.L
\family default
 will end up pointing at the start of the data area for the body of the
 function.
 Because of this, I need to use some negative offsets when the code needs
 to refer to the header fields.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cbSize equ -6    ; Actual allocated size of buffer data area.
\end_layout

\begin_layout Plain Layout

cbHead equ -4    ; Head offset within data area.
\end_layout

\begin_layout Plain Layout

cbTail equ -2    ; Tail offset within data area.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All the code for this article can be found in the code files supplied in
 the download.
 The various functions explained below are found in 
\family typewriter
cBuffer_asm
\family default
.
\end_layout

\begin_layout Subsection
Allocate a New Buffer
\end_layout

\begin_layout Standard
Allocating a new circular buffer is a simple matter of taking the requested
 space, rounding it up to the next power of two, add making it a long word
 to fit into 
\family typewriter
D1
\family default
 and adding the 6 extra bytes required for the header.
 A chunk of common heap is then requested from QDOSMSQ and if it was allocated,
 the header fields are filled in.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Allocating-a-circular-buffer"

\end_inset

 is the code to allocate a new circular buffer.
 This code calls the 
\family typewriter
checkSize
\family default
 procedure to adjust the buffer size.
 That code can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Adjusting-a-buffers-size"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

MT_ALCHP equ $18    ; Allocate common heap
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Allocate Buffer
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Allocates memory for a new circular buffer.
 The size passed
\end_layout

\begin_layout Plain Layout

; must be a power of 2 and cannot be larger than a word.
 This
\end_layout

\begin_layout Plain Layout

; limits a buffer to a maximum size of 32,768 bytes.
 1 of which
\end_layout

\begin_layout Plain Layout

; will be unusable.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.W = Size of buffer.
 Power of two, 32768 maximum.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.L = Error code.
 (From MT_ALCHP)
\end_layout

\begin_layout Plain Layout

;      = 0 if the buffer was created.
\end_layout

\begin_layout Plain Layout

;      <>0 if the buffer failed to create.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer address.
 (A3 -> cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

allocateBuffer
\end_layout

\begin_layout Plain Layout

        movem.l d1-d3/a0-a2,-(a7) ; Save working registers
\end_layout

\begin_layout Plain Layout

		bsr.s checkSize         ; Returns D0.L as a power of 2
\end_layout

\begin_layout Plain Layout

        move.l d0,d1            ; D1.L = space required
\end_layout

\begin_layout Plain Layout

        addq.l #6,d1            ; Adjust for header space
\end_layout

\begin_layout Plain Layout

        moveq #MT_ALCHP,d0      ; Allocate common heap
\end_layout

\begin_layout Plain Layout

        moveq #-1,d2            ; Current job is owner
\end_layout

\begin_layout Plain Layout

        trap #1
\end_layout

\begin_layout Plain Layout

        tst.l d0                ; Do we allocate some heap?
\end_layout

\begin_layout Plain Layout

        bne.s abExit            ; No       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        move.l a0,a3            ; Buffer address in A3.L
\end_layout

\begin_layout Plain Layout

        subq.w #6,d1            ; Size of buffer data area
\end_layout

\begin_layout Plain Layout

        move.w d1,(a3)          ; Set cbSize 
\end_layout

\begin_layout Plain Layout

        clr.l 2(a3)             ; Set cbHead = cbTail = 0           
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abExit
\end_layout

\begin_layout Plain Layout

        movem.l (a7)+,d1-d3/a0-a2 ; Restore working registers
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Allocating a circular buffer
\begin_inset CommandInset label
LatexCommand label
name "lis:Allocating-a-circular-buffer"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All registers except 
\family typewriter
D0
\family default
 and 
\family typewriter
A3
\family default
 are preserved by the allocate Buffer routine.
 The code is called with the required buffer size in 
\family typewriter
D0.W
\family default
 and if successful, 
\family typewriter
D0
\family default
 will hold zero and 
\family typewriter
A3.L
\family default
 will return the buffer address.
 In the case of an error, 
\family typewriter
D0
\family default
 will return the error code from 
\family typewriter
MT_ALCHP
\family default
 and 
\family typewriter
A3
\family default
 will be unchanged.
\end_layout

\begin_layout Subsection
Buffer Size Adjustments
\end_layout

\begin_layout Standard
In order to protect the programmer from him or herself, the allocation of
 a buffer will check that the size requested is within range.
 The code in the 
\family typewriter
checkSize
\family default
 routine takes the value in 
\family typewriter
D0.W
\family default
 and rounds it up to the next power of two, unless its already a power.
 The resulting value, in 
\family typewriter
D0.L
\family default
 is then adjusted to a maximum of 32768 or a minimum of 8 bytes.
\end_layout

\begin_layout Standard
The code should be reasonably familiar as it was in Issue 8 of this somewhat
 irregular eMagazine.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Adjusting-a-buffers-size"

\end_inset

 shows the code to check and make the adjustments as necessary.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Check Size
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Check the requested buffer size in D0 and round it up to the
\end_layout

\begin_layout Plain Layout

; next largest power of two if not already a power.
 If less 
\end_layout

\begin_layout Plain Layout

; than 8 bytes, make it 8.
 If more than 32768, then make it 
\end_layout

\begin_layout Plain Layout

; 32768.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.W = Size of buffer.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.L = Potentially adjusted buffer size.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Algorithm:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; Value = Value - 1
\end_layout

\begin_layout Plain Layout

; REPEAT LOOP
\end_layout

\begin_layout Plain Layout

;   Temp = Value & (Value - 1)
\end_layout

\begin_layout Plain Layout

;   If Temp = 0, return min(max(2*Value, 8), 32768)
\end_layout

\begin_layout Plain Layout

;   Value = Temp
\end_layout

\begin_layout Plain Layout

; END LOOP
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D1.L = Value
\end_layout

\begin_layout Plain Layout

; D0.L = Temp
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

checkSize
\end_layout

\begin_layout Plain Layout

        move.l d1,-(a7)     ; Save the worker
\end_layout

\begin_layout Plain Layout

        moveq #0,d1
\end_layout

\begin_layout Plain Layout

        move.w d0,d1        ; D1.L = Value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        subq.l #1,d1        ; In case Value is a power already
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

csLoop
\end_layout

\begin_layout Plain Layout

        move.l d1,d0        ; Temp = Value
\end_layout

\begin_layout Plain Layout

        subq.l #1,d0        ; Temp = (Value - 1)
\end_layout

\begin_layout Plain Layout

        and.l d1,d0         ; Temp = Value & (Value - 1)
\end_layout

\begin_layout Plain Layout

        beq.s csRange       ; If Temp = Zero = no more set bits
\end_layout

\begin_layout Plain Layout

        move.l d0,d1        ; Value = Temp
\end_layout

\begin_layout Plain Layout

        bne.s csLoop        ; Keep going
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

csRange
\end_layout

\begin_layout Plain Layout

        lsl.l #1,d1         ; Value = Value * 2
\end_layout

\begin_layout Plain Layout

        move.l d1,d0        ; To return the new value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

csMin
\end_layout

\begin_layout Plain Layout

        cmpi.l #8,d0        ; Minimum is 8
\end_layout

\begin_layout Plain Layout

        bhi.s csMax         ; Bigger than 8
\end_layout

\begin_layout Plain Layout

        moveq #8,d0         ; Result is 8
\end_layout

\begin_layout Plain Layout

        bra.s csExit        ; Done
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

csMax
\end_layout

\begin_layout Plain Layout

        cmpi.l #$8000,d0    ; Maximum is 32768
\end_layout

\begin_layout Plain Layout

        ble.s csExit        ; Equal/Smaller than 32768
\end_layout

\begin_layout Plain Layout

        move.l #$8000,d0    ; Result is 32768
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

csExit
\end_layout

\begin_layout Plain Layout

        move.l (a7)+,d1     ; Restore worker
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Adjusting a buffer's size
\begin_inset CommandInset label
LatexCommand label
name "lis:Adjusting-a-buffers-size"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to test if a number is a power of two, start with one less than
 the number – in case it's already a power – then repeatedly assign the
 value with 
\begin_inset Formula $(value\ AND\ (value-1))$
\end_inset

 and when the result is zero, you have the power of two 
\emph on
below
\emph default
 the original number, to get the next one, multiply by two.
\end_layout

\begin_layout Standard
The result, in 
\family typewriter
D0.L
\family default
, is now a power of two.
 Given that a buffer size of less than 8 is most likely a waste of time,
 the buffer size is rounded up to 8 if smaller.
 If the size exceeds the maximum that a word can hold, 32768, it is adjusted
 down to 32768.
\end_layout

\begin_layout Subsection
Free a Buffer
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Freeing-a-circular-buffer"

\end_inset

 shows the code to free a circular buffer after it is no longer required.
 Obviously in a job, this is not strictly necessary as QDOSMSQ will tidy
 up the jobs allocated heaps space on exit, however, it's best to be neat
 and tidy, plus, deallocating the space when no longer needed can free the
 space for other tasks to utilise.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

MT_RECHP equ $19    ; Release common heap
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Free Buffer
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; deallocates memory for a circular buffer.
 
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer address.
 (A3 -> cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Corrupted.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

freeBuffer
\end_layout

\begin_layout Plain Layout

        movem.l d0-d3/a0-a2,-(a7) ; Save working registers
\end_layout

\begin_layout Plain Layout

        move.l a3,a0            ; Buffer address
\end_layout

\begin_layout Plain Layout

        moveq #MT_RECHP,d0      ; Release common heap
\end_layout

\begin_layout Plain Layout

        trap #1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fbExit
\end_layout

\begin_layout Plain Layout

        movem.l (a7)+,d0-d3/a0-a2 ; Restore working registers
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Freeing a circular buffer
\begin_inset CommandInset label
LatexCommand label
name "lis:Freeing-a-circular-buffer"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There's not a lot to explain here, the base address of the buffer is passed
 in 
\family typewriter
A3
\family default
 as usual, and is simply copied to 
\family typewriter
A0
\family default
 in order for the trap to release common heap space, to work.
 releasing a heap never fails with any errors, so none are checked for.
\end_layout

\begin_layout Standard
All registers, except 
\family typewriter
A3
\family default
, are preserved by this code.
\end_layout

\begin_layout Subsection
Write Data to a Buffer
\end_layout

\begin_layout Standard
When adding a byte to a buffer, the buffer cannot be full up, that indicates
 an error condition.
 If the buffer has free space, then the head offset is adjusted to the next
 free space and the data byte stored at that offset into the data area of
 the buffer.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Writing-data-to-a-buffer"

\end_inset

 shows the code for the 
\family typewriter
addByte
\family default
 procedure..
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Add Byte
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Adds one byte to a circular buffer.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D1.B = Byte to be added.
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer to add to.
 (A3 -> cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.L = Error code.
\end_layout

\begin_layout Plain Layout

;      = 0 if the byte was added to the buffer.
\end_layout

\begin_layout Plain Layout

;      = 1 if the buffer is full, so D1 was not added.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

addByte
\end_layout

\begin_layout Plain Layout

        movem.w d1/d4-d5/a3,-(a7) ; Save working registers
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abIsFull
\end_layout

\begin_layout Plain Layout

        bsr.s isFull            ; Preserves all registers
\end_layout

\begin_layout Plain Layout

        beq.s abFullUp          ; Yes, bale out        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d5         ; Size of buffer
\end_layout

\begin_layout Plain Layout

        subq.w #1,d5            ; We need one less than size
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d4         ; Where is the head?
\end_layout

\begin_layout Plain Layout

        addq.l #2,a3            ; Skip over the tail, not used
\end_layout

\begin_layout Plain Layout

        addq.w #1,d4            ; New head pointer
\end_layout

\begin_layout Plain Layout

        and.w d5,d4             ; Wrap around if necessary
\end_layout

\begin_layout Plain Layout

        move.b d1,(a3,d4.w)     ; Store new byte
\end_layout

\begin_layout Plain Layout

        move.w d4,cbHead(a3)    ; New head saved
\end_layout

\begin_layout Plain Layout

        moveq #0,d0             ; One byte added
\end_layout

\begin_layout Plain Layout

        bra.s abExit            ; Done, no errors.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abFullUp
\end_layout

\begin_layout Plain Layout

        moveq #1,d0             ; Buffer full, can't add D1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abExit
\end_layout

\begin_layout Plain Layout

        movem.w (a7)+,d1/d4-d5/a3 ; Restore working registers
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Writing data to a buffer
\begin_inset CommandInset label
LatexCommand label
name "lis:Writing-data-to-a-buffer"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code starts by calling the 
\family typewriter
isFull
\family default
 routine to determine if the buffer is full.
 If 
\family typewriter
D0
\family default
 is returned as zero, then the buffer is indeed full and we bale out with
 an error code in 
\family typewriter
D0
\family default
.
 We cannot add this byte to the buffer.
\end_layout

\begin_layout Standard

\family typewriter
D5
\family default
 is then set to the buffer size minus 1.
 We use this to MOD the head offset when it is incremented, to enable it
 to wrap around from the final byte to the start byte, if required.
 The head offset is copied into 
\family typewriter
D4
\family default
 and as we don't need the tail, 
\family typewriter
A3
\family default
 is incremented past it to point at the start of the data area of the buffer.
 The data byte in D1 is then stored in the buffer at the new head position.
\end_layout

\begin_layout Standard
The new head offset is written back to the correct location in the buffer
 header, which is at a negative offset from the current value in 
\family typewriter
A3
\family default
.
\end_layout

\begin_layout Standard
The sharp eyed and quick brained amongst you may be thinking, 
\begin_inset Quotes eld
\end_inset


\emph on
Hmmmm, what about that 
\emph default

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

move.b d1,(a3,d4.w)
\end_layout

\end_inset


\emph on
 instruction, to store the new data byte, as the index register is a word,
 surely it will be sign extended? The maximum buffer is 32768 after all
 and that's got a sign bit of 1 after all.
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Funnily enough, I thought that too for a bit, however, the absolute maximum
 value that the head or tail offsets can take is one less than the buffer
 size – buffer offsets are from zero – so that makes 32767 or $7FFF the
 maximum, and that doesn't have a leading 1 in the sign bit, so all is well.
\end_layout

\begin_layout Subsection
Read Data from a Buffer
\end_layout

\begin_layout Standard
Reading data from a buffer is quite simple.
 If the buffer is empty, then there's nothing to do as there's nothing to
 actually read.
 Assuming the buffer does have data, then the tail offset is incremented,
 wrapping around if necessary, and the byte at that offset is obtained.
 The new tail pointer is then stored in the buffer header.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Reading-data-from-a-buffer"

\end_inset

 shows the 
\family typewriter
getByte
\family default
 code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Get Byte
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Gets one byte from a circular buffer.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer to get from.
 (A3 = cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.L = Error code.
\end_layout

\begin_layout Plain Layout

;      = 0 if the byte was retrieved from the buffer.
\end_layout

\begin_layout Plain Layout

;      = 1 if the buffer is empty.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D1.B = The retrieved byte, if the buffer was not empty.
\end_layout

\begin_layout Plain Layout

;      = Preserved if the buffer was empty.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

getByte
\end_layout

\begin_layout Plain Layout

        movem.w d4-d6/a3,-(a7)  ; Save working registers
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

gbIsEmpty
\end_layout

\begin_layout Plain Layout

        bsr.s isEmpty           ; Is the buffer empty?
\end_layout

\begin_layout Plain Layout

        beq.s gbEmpty           ; Yes, bale out
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d5         ; Size of buffer
\end_layout

\begin_layout Plain Layout

        subq.w #1,d5            ; We need one less than size
\end_layout

\begin_layout Plain Layout

        addq.l #2,a3            ; Skip over the head
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d6         ; Get the tail?
\end_layout

\begin_layout Plain Layout

        addq.w #1,d6            ; New tail pointer
\end_layout

\begin_layout Plain Layout

        and.w d5,d6             ; Wrap around if necessary
\end_layout

\begin_layout Plain Layout

        move.b (a3,d6.w),d1     ; Fetch byte
\end_layout

\begin_layout Plain Layout

        move.w d6,cbTail(a3)    ; New tail saved
\end_layout

\begin_layout Plain Layout

        moveq #0,d0             ; One byte retrieved
\end_layout

\begin_layout Plain Layout

        bra.s gbExit            ; Done, no errors
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

gbEmpty
\end_layout

\begin_layout Plain Layout

        moveq #1,d0             ; Buffer empty, can't retrieve
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

gbExit
\end_layout

\begin_layout Plain Layout

        movem.w (a7)+,d4-d6/a3  ; Restore working registers
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Reading data from a buffer
\begin_inset CommandInset label
LatexCommand label
name "lis:Reading-data-from-a-buffer"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code begins by calling out to 
\family typewriter
isEmpty
\family default
 and if the buffer is empty, bales out setting 
\family typewriter
D0
\family default
 to 1 to show a read from an empty buffer was attempted.
\end_layout

\begin_layout Standard
The buffer size is copied into 
\family typewriter
D5.W
\family default
 and decremented.
 This is used later to MOD the new tail offset to make sure it wraps around,
 if required.
 The head offset is not required so is skipped over leaving 
\family typewriter
A3.L
\family default
 pointing at the tail, which is read into 
\family typewriter
D6
\family default
.W.
 The tail offset is then incremented, wrapping as appropriate to give the
 offset into the data area that we will read from.
 
\end_layout

\begin_layout Standard
The data byte at the calculated offset is copied into D1 and the new tail
 offset stored in the buffer's header.
 
\family typewriter
D0
\family default
 is cleared to show that no errors occurred.
\end_layout

\begin_layout Subsection
Is the Buffer Full?
\end_layout

\begin_layout Standard
The buffer is full up whenever the tail offset is 1 byte larger than the
 head.
 This is because 
\begin_inset Formula $head+1\ MOD\ buffer\_size$
\end_inset

 is where the next data byte will be written to the buffer.
 The tail offset, whatever it currently happens to be, is where the most
 recent byte was read from the buffer.
 As previously explained, we have to compare the incremented head offset
 with the current tail offset or we will be unable to determine if the buffer
 is empty or full when both are equal.
\end_layout

\begin_layout Standard
It is this increment to the head offset which causes the loss of a single
 byte of storage in the buffer.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Is Full?
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Checks if the buffer passed in A3 is full.
 A buffer is full 
\end_layout

\begin_layout Plain Layout

; when (Head + 1) MOD size == Tail.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer to get from.
 (A3 -> cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.L = Error code.
\end_layout

\begin_layout Plain Layout

;      = 0 if the buffer is full.
 Z set.
\end_layout

\begin_layout Plain Layout

;      = 1 if the buffer is not full.
 Z clear.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

isFull
\end_layout

\begin_layout Plain Layout

        movem.l d4-d5/a3,-(a7)  ; Save the workers
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d4         ; Get the buffer size
\end_layout

\begin_layout Plain Layout

        subq.w #1,d4            ; Minus 1 for MOD
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d5         ; Get the head offset
\end_layout

\begin_layout Plain Layout

        addq.w #1,d5            ; Next head offset
\end_layout

\begin_layout Plain Layout

        and.w d4,d5             ; MOD buffer size
\end_layout

\begin_layout Plain Layout

        cmp.w (a3),d5           ; Same as tail?
\end_layout

\begin_layout Plain Layout

        beq.s ifFull            ; Buffer is full
\end_layout

\begin_layout Plain Layout

        moveq #1,d0             ; Not full
\end_layout

\begin_layout Plain Layout

        bra.s ifExit            ; Bale out
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ifFull        
\end_layout

\begin_layout Plain Layout

        moveq #0,d0             ; Buffer is full
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ifExit
\end_layout

\begin_layout Plain Layout

        movem.l (a7)+,d4-d5/a3  ; Restore the workers
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Is buffer full
\begin_inset CommandInset label
LatexCommand label
name "lis:Is-buffer-full"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code is simple enough, the buffer's size is copied into 
\family typewriter
D4.W
\family default
 and decremented ready for the MOD to take place.
 The head offset is copied into 
\family typewriter
D5.W
\family default
 and incremented.
 The new value is ANDed with 
\family typewriter
D4.W
\family default
 to cope with t he new value needing to wrap around to the beginning of
 the buffer.
 The new value is compared with the tail offset and if they are equal, the
 buffer is full.
 This is indicated by a return value of zero in 
\family typewriter
D0
\family default
.
 Returning 1 in 
\family typewriter
D0
\family default
 indicates that the buffer is not full.
\end_layout

\begin_layout Subsection
Is the Buffer Empty?
\end_layout

\begin_layout Standard
This is rather easy.
 If the head pointer equals the tail pointer, then the buffer is currently
 empty.
 For a brand new buffer, both offsets are zero and the buffer is definitely
 empty.
\end_layout

\begin_layout Standard
If, on the other hand, 10 bytes had been added since new, and none read
 back yet, the head will be 10 while the tail will be still zero.
 Don't I mean 9 for the head? No, definitely 10 because while the head (and
 tail) starts at zero in a new buffer, it is incremented by 1 
\emph on
before
\emph default
 storing a new byte as explained above.
 The first byte added will be at offset 1 for a new buffer, the second at
 offset 2 and so the tenth will be at offset 10.
\end_layout

\begin_layout Standard
After reading back the 10 bytes, the tail offset will also be at 10, so
 both are equal and the buffer is indeed empty.
\end_layout

\begin_layout Standard
Interestingly, a new, empty, buffer need not have the head and tail offsets
 set to zero, it makes no difference where they both point, provided they
 point at the same offset.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Is Empty?
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Checks if the buffer passed in A3 is empty.
 A buffer is empty 
\end_layout

\begin_layout Plain Layout

; when Head == Tail.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer to get from.
 (A3 = cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.L = Error code.
\end_layout

\begin_layout Plain Layout

;      = 0 if the buffer is empty.
 Z set.
\end_layout

\begin_layout Plain Layout

;      = 1 if the buffer is not empty.
 Z clear.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

isEmpty
\end_layout

\begin_layout Plain Layout

        cmp.w -cbHead(a3),-cbTail(a3)    ; Head = Tail? 
\end_layout

\begin_layout Plain Layout

        beq.s ieEmpty                    ; Yes
\end_layout

\begin_layout Plain Layout

        moveq #1,d0                      ; Not empty
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ieEmpty
\end_layout

\begin_layout Plain Layout

        moveq #0,d0                      ; No
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Is buffer empty
\begin_inset CommandInset label
LatexCommand label
name "lis:Is-buffer-empty"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
How Much Space is Used?
\end_layout

\begin_layout Standard
This is calculated as 
\begin_inset Formula $(buffer\_size+head-tail)\ MOD\ buffer\_size$
\end_inset

.
 If we assume a status as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Circular-Buffer-space-used-simple-example"

\end_inset

 we can see a simple example where 4 bytes of data have been written to
 a new buffer but nothing has been read back yet.
 The first byte has an unknown value as it was never written to since the
 buffer was created.
 The 4 bytes written are 
\begin_inset Quotes els
\end_inset

A
\begin_inset Quotes ers
\end_inset

, 
\begin_inset Quotes ers
\end_inset

B
\begin_inset Quotes ers
\end_inset

, 
\begin_inset Quotes ers
\end_inset

C
\begin_inset Quotes ers
\end_inset

 and 
\begin_inset Quotes ers
\end_inset

D
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="11">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbSize
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbHead
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbTail
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbData
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?
\begin_inset script subscript

\begin_layout Plain Layout
tail
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\begin_inset script subscript

\begin_layout Plain Layout
head
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Circular Buffer space used - simple example 
\begin_inset CommandInset label
LatexCommand label
name "fig:Circular-Buffer-space-used-simple-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is an obvious one, there are 4 bytes used, we can see that plainly.
 And the calculation gives the correct result:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\left(buffer\_size+head-tail\right) & \ MOD\ buffer\_size\\
\left(8+4-0\right) & \ MOD\ 8\\
12 & \ MOD\ 8
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
And 
\begin_inset Formula $12\ MOD\ 8$
\end_inset

 is indeed 4.
\end_layout

\begin_layout Standard
How about when the buffer has been used for a while and the situation resembles
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Circular-Buffer-space-used-comples-example"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="11">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbSize
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbHead
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbTail
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
cbData
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\begin_inset script subscript

\begin_layout Plain Layout
head
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\begin_inset script subscript

\begin_layout Plain Layout
tail
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Circular Buffer space used - complex example 
\begin_inset CommandInset label
LatexCommand label
name "fig:Circular-Buffer-space-used-comples-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example, the last byte written was at offset 2 (
\begin_inset Formula $head=2$
\end_inset

), the 'A', while the last byte read back was at offset 5 (tail = 5), the
 'E'.
 We can plainly see that the bytes F, G, Y, Z and A have yet to be read
 and so must be included in the count, while the data bytes C, D and E have
 already been read back and are thus classed as free space now.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\left(buffer\_size+head-tail\right) & \ MOD\ buffer\_size\\
\left(8+2-5\right) & \ MOD\ 8\\
5 & \ MOD\ 8
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
And 
\begin_inset Formula $5\ MOD\ 8$
\end_inset

 is 5 and there are 5 unread bytes in the buffer – F, G, Y, Z and A.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Buffer-space-used"

\end_inset

 shows the code to work out how much data is available in a buffer.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Get Used
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Returns the space used in a buffer.
 This is (size + head -
\end_layout

\begin_layout Plain Layout

; tail) MOD size.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer to get from.
 (A3 = cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.W = Used space.
\end_layout

\begin_layout Plain Layout

;      = 0 if the buffer is empty.
 Z set.
\end_layout

\begin_layout Plain Layout

;      <> 0 = used space.
 Z clear.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

getUsed
\end_layout

\begin_layout Plain Layout

        movem.l d5/a3,-(a7)     ; Save the workers
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

guIsEmpty
\end_layout

\begin_layout Plain Layout

        bsr.s isEmpty           ; Is buffer empty?
\end_layout

\begin_layout Plain Layout

        beq.s guExit            ; Yes, D0 = 0, bale out
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d0         ; Buffer size
\end_layout

\begin_layout Plain Layout

        move.w d0,d5            ; Buffer size again
\end_layout

\begin_layout Plain Layout

        subq.w #1,d5            ; For MOD
\end_layout

\begin_layout Plain Layout

        add.w (a3)+,d0          ; Add on head
\end_layout

\begin_layout Plain Layout

        sub.w (a3),d0           ; Minus tail
\end_layout

\begin_layout Plain Layout

        andw.l d5,d0            ; MOD size
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

guExit
\end_layout

\begin_layout Plain Layout

        movem.l (a7)+,d5/a3     ; Restore the workers
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Buffer space used
\begin_inset CommandInset label
LatexCommand label
name "lis:Buffer-space-used"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the buffer is empty, then we exit from the code with 
\family typewriter
D0
\family default
 holding zero.
 The buffer size is copied into 
\family typewriter
D0.W
\family default
 and 
\family typewriter
D5.W
\family default
.
 
\family typewriter
D5.W
\family default
 is then decremented ready for the MOD operation later.
 The current head offset is added to D0.W and the tail offset is subtracted.
 
\family typewriter
D0.W
\family default
 is finally ANDed with 
\family typewriter
D5.W
\family default
 to obtain the final result for 
\begin_inset Formula $(buffer\_size+head-tail)\ MOD\ buffer\_size$
\end_inset

.
\end_layout

\begin_layout Standard
Can the results ever overflow a word sized register? No.
 The biggest buffer allowed is 32768 which is $8000, in that buffer the
 maximum head offset to add on is 32767 or $7FFF, this gives 65535 or $FFFF
 – so it all fits into a word before subtracting the tail offset, the smallest
 of which is zero.
 The result must always fit into a word sized register, so we are good.
\end_layout

\begin_layout Subsection
How Much Space is Free?
\end_layout

\begin_layout Standard
The space available in a buffer is 
\begin_inset Formula $buffer\_size-1-space\_used$
\end_inset

.
 The code below in Listing
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Buffer-free-space"

\end_inset

 does exactly this.
 It could also use the full formula of 
\begin_inset Formula $buffer\_size-1-\left(\left(buffer\_size+head-tail\right)\ MOD\ buffer\_size\right)$
\end_inset

 but when half the work has been done already, it's a shame to repeat it!
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Get Free
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

; Returns the space free in a buffer.
 This is size - 1 - used.
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; ENTRY:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; A3.L = Buffer to get from.
 (A3 = cbSize in the buffer.)
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT:
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; D0.L = Space used in the buffer.
 
\end_layout

\begin_layout Plain Layout

;      Z set if buffer is full.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; All other registers are preserved.
\end_layout

\begin_layout Plain Layout

;--------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

getFree
\end_layout

\begin_layout Plain Layout

        move.l a3,-(a7)         ; Save the worker
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

gfIsEmpty
\end_layout

\begin_layout Plain Layout

        bsr.s getUsed           ; D0.W = used space
\end_layout

\begin_layout Plain Layout

        neg.w d0                ; negative used size
\end_layout

\begin_layout Plain Layout

        add.w (a3),d0           ; Add buffer size
\end_layout

\begin_layout Plain Layout

        subq.w #1,d0            ; Minus the unusable byte
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

gfExit
\end_layout

\begin_layout Plain Layout

        move.l (a7)+,a3         ; Restore the worker
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Buffer free space
\begin_inset CommandInset label
LatexCommand label
name "lis:Buffer-free-space"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code is quite simple here as well.
 
\family typewriter
D0.W
\family default
 is set to the amount of space used in the buffer, this is then negated
 and the buffer size is added on.
 The single unusable byte is then subtracted to get the final result.
 
\end_layout

\begin_layout Subsection
Incrementing Head and Tail Offsets
\end_layout

\begin_layout Standard
The various procedures explained above all increment their offsets for head
 and tail, on the fly, rather than calling out to another subroutine.
 This is mainly because the increment code is pretty small and it's hardly
 worth calling a sub-routine to do the work.
\end_layout

\begin_layout Standard
Incrementing an offset is a simple case of 
\begin_inset Formula $\left(offset+1\right)\ MOD\ buffer\_size$
\end_inset

.
 We need the MOD function as the offset has to wrap from 
\begin_inset Formula $buffersize-1$
\end_inset

 to zero when we reach the end of the buffer.
 
\end_layout

\begin_layout Standard
This is another reason why the buffer size is required to be a power of
 two.
 When those values are used, we can quickly MOD a value by ANDing with the
 buffer size minus 1 – as the code has been doing throughout.
 
\end_layout

\begin_layout Standard
For example, if our buffer size is 8 bytes, the ANDing with 7 is effectively
 the MOD 8 operation that we need.
 The offset into the buffer, head or tail, will always be from 0 to 7 inclusive.
 When we increment from 7 to 8, we go outside the bounds of the buffer's
 data area so we need to wrap back to the start.
 
\end_layout

\begin_layout Standard
In binary 8 is 0000 1000 and 7 is 0000 0111.
 If we AND them together, we get 0000 0000 which is exactly where we want
 to be, back at offset zero.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Incrementing-an-offset-using-AND"

\end_inset

 shows an example of this in code form, where we pick up the head pointer
 and increment it.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

incHead
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d4         ; Get the buffer size
\end_layout

\begin_layout Plain Layout

        subq.w #1,d4            ; Minus 1 for MOD
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d5         ; Get the head offset
\end_layout

\begin_layout Plain Layout

        addq.w #1,d5            ; Next head offset
\end_layout

\begin_layout Plain Layout

        and.w d4,d5             ; MOD buffer size
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Incrementing an offset using AND
\begin_inset CommandInset label
LatexCommand label
name "lis:Incrementing-an-offset-using-AND"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the buffer sizes could be any value, then we would be into the realms
 of having to divide and take the remainder.
 Not that this is a huge problem, in fact, if you wish, you can rewrite
 the code to allow for buffer sizes which are not powers of two, call it
 homework!
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Incrementing-an-offset-using-DIVU"

\end_inset

 shows an example of incrementing the head offset using the 
\family typewriter
DIVU
\family default
 instruction.
 This requires that a long value in the destination register be divided
 by a word value in the source.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

incHead
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d4         ; Get the buffer size
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d5         ; Get the head offset
\end_layout

\begin_layout Plain Layout

        ext.l d5                ; For DIVU
\end_layout

\begin_layout Plain Layout

        addq.l #1,d5            ; Next head offset
\end_layout

\begin_layout Plain Layout

        divu d4,d5              ; Divide by buffer size
\end_layout

\begin_layout Plain Layout

        swap d5                 ; Remainder in low word
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Incrementing an offset using DIVU
\begin_inset CommandInset label
LatexCommand label
name "lis:Incrementing-an-offset-using-DIVU"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have to take care here not to increment the head pointer until 
\emph on
after
\emph default
 it has been sign extended to a long – if the value happened to be 32767,
 $7FFF, and it was incremented to $8000, it would be sign extended to $FFFF
 8000 and after the division, the new head pointer would be wrong! Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Correct-offset-incrementing-with-DIVU"

\end_inset

 shows the code again, but this time, with the register values displayed
 as comments.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

incHead
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d4         ; D4 = xxxx 8000
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d5         ; D5 = xxxx 7FFF
\end_layout

\begin_layout Plain Layout

        ext.l d5                ; D5 = 0000 7FFF
\end_layout

\begin_layout Plain Layout

        addq.l #1,d5            ; D5 = 0000 8000
\end_layout

\begin_layout Plain Layout

        divu d4,d5              ; D5 = 0000 0001
\end_layout

\begin_layout Plain Layout

        swap d5                 ; Remainder = 0000
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Correct offset incrementing with DIVU
\begin_inset CommandInset label
LatexCommand label
name "lis:Correct-offset-incrementing-with-DIVU"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
And Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Incorrect-offset-incrementing-with-DIVU"

\end_inset

 is the code where we increment the offset 
\emph on
before
\emph default
 we extend the register to a long value.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

incHead
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d4         ; D4 = xxxx 8000
\end_layout

\begin_layout Plain Layout

        move.w (a3)+,d5         ; D5 = xxxx 7FFF
\end_layout

\begin_layout Plain Layout

        addq.w #1,d5            ; D5 = 0000 8000
\end_layout

\begin_layout Plain Layout

        ext.l d5                ; D5 = FFFF 8000
\end_layout

\begin_layout Plain Layout

        divu d4,d5              ; D5 = FFFF 8000
\end_layout

\begin_layout Plain Layout

        swap d5                 ; Remainder = FFFF !!!!!!!
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Incorrect offset incrementing with DIVU
\begin_inset CommandInset label
LatexCommand label
name "lis:Incorrect-offset-incrementing-with-DIVU"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We expected the remainder to be zero, and yet it's actually 65535.
 This is, as noted, 
\emph on
slightly
\emph default
 incorrect.
\end_layout

\begin_layout Subsection
QPC2 Bug? Or My Mistake?
\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Correct-offset-incrementing-with-DIVU"

\end_inset

 I show the result of the 
\family typewriter
DIVU
\family default
 instruction as 
\family typewriter
D5 = $0001 FFFF
\family default
 which is correct.
 When I was making sure that I wasn't talking rubbish again
\begin_inset Foot
status open

\begin_layout Plain Layout
it happens
\end_layout

\end_inset

 regarding Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Incorrect-offset-incrementing-with-DIVU"

\end_inset

, I traced the code through with QMON2.
 I could see that the 
\family typewriter
DIVU
\family default
 instruction gave the result as 
\family typewriter
D5 = $FFFF 8000
\family default
 which is completely wrong!
\end_layout

\begin_layout Standard
I mentioned this problem on the 
\begin_inset CommandInset href
LatexCommand href
name "this topic on QLForum"
target "https://qlforum.co.uk/viewtopic.php?f=19&t=3966&p=44307#p44295"
literal "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
The URL is https://qlforum.co.uk/viewtopic.php?f=19&t=3966&p=44307#p44295 if
 you have printed out a copy of this issue of the eMagazine.
\end_layout

\end_inset

 as I thought I might have found a corner case bug in QPC2.
 I hadn't of course.
\end_layout

\begin_layout Standard
The problem was, when I traced the code, and saw the result of the division
 being so obviously wrong, I leapt to the conclusion that it had to be a
 bug.
 Unfortunately, what I had neglected to do was 
\emph on
look at the flags
\emph default
.
 Had I done so, I would have noticed the 
\family typewriter
V
\family default
 flag, overflow, was set after the division.
 Duh!
\end_layout

\begin_layout Standard
The error of my ways was pointed out by Marcel and Tobias.
 Thanks to them, for being gentle with me!
\end_layout

\begin_layout Standard
The manual for the 68008 says that 
\begin_inset Quotes eld
\end_inset


\emph on
Overflow may be detected and set before the instruction completes.
 If the instruction detects an overflow, it sets the overflow condition
 code and the operands are unaffected.
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Look at the values in the 
\family typewriter
D5.L
\family default
 register just before and after the 
\family typewriter
DIVU
\family default
 instruction? They are exactly the same.
 
\end_layout

\begin_layout Standard
Had the division been a valid one, it would have resulted in a quotient
 of 
\family typewriter
$0001 FFFF
\family default
 and no remainder.
 The quotient is larger than a word, so wouldn't have fitted in 
\family typewriter
D5.W
\family default
 where it should go.
 The overflow was detected and dealt with 
\emph on
exactly
\emph default
 as specified in the manual.
 And I missed it, completely! Even though I used a couple of hex calculators
 to check what the answer 
\emph on
should
\emph default
 have been and 
\emph on
knew
\emph default
 something was wrong with 
\family typewriter
$0001 FFFF
\family default
, I didn't twig the the obvious fact that the quotient was 
\emph on
bigger than a word
\emph default
.
 Not that it wasn't staring me in the face!
\end_layout

\begin_layout Standard
So, don't be like me, watch the flags when something goes weird on you,
 and make sure you haven't done, or missed, anything silly!
\end_layout

\begin_layout Standard

\series bold
NOTE
\series default
: As I'm running QPC2, I have the benefit of the 68020 CPU rather than the
 68008.
 The 68020 has a 
\family typewriter
DIVU.L <ea>,Dq:Dr
\family default
 instruction which takes a 32 bit value in the effective address, divides
 by the 
\family typewriter
Dq
\family default
 register and places a 32 bit quotient in 
\family typewriter
Dq
\family default
 with the remainder in 
\family typewriter
Dr
\family default
.
 This will not work on a bare bones QL of course.
\end_layout

\begin_layout Section
Test Harness
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Write some code to test the buffer code.
 Is it at all possible to have a job running which simply polls the buffer
 for data, and an interrupt job that constantly fills it? Too complex? What
 about race conditions? Think about it.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
