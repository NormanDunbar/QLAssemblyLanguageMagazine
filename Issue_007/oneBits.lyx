#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
% Required for the setup of the listings.
\usepackage{xcolor}
\definecolor{ocre}{RGB}{243,102,25}
\definecolor{wwwDarkGreen}{HTML}{006400}
\definecolor{wwwDarkOrchid}{HTML}{9932CC}
\definecolor{wwwDarkOrange}{HTML}{FF8C00}
% Added by lyx2lyx
\renewcommand{\textendash}{--}
\renewcommand{\textemdash}{---}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "PlatformIO for the Arduino User"
\pdf_author "Norman Dunbar"
\pdf_subject "PlatformIO"
\pdf_keywords "PlatformIO Arduino AVR ATMEGA ATMEGA328"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\boxbgcolor #ff557f
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "backgroundcolor={\color{ocre!10}},basicstyle={\small},breakatwhitespace=false,breaklines=false,captionpos=b,commentstyle={\color{wwwDarkGreen}},deletekeywords={...},escapeinside={\%*}{*)},extendedchars=true,frame=leftline,framerule=4pt,keepspaces=true,keywordstyle={\color{blue}},morekeywords={*,...},numbers=left,numbersep=10pt,numberstyle={\color{ocre}},rulecolor={\color{ocre}},showspaces=false,showstringspaces=false,showtabs=false,stepnumber=1,stringstyle={\color{wwwDarkOrange}},tabsize=2,title={\lstname},breaklines=true,postbreak={\mbox{\textcolor{ocre}{\textbf{$\Longrightarrow$}}\space}},language={[Motorola68k]Assembler}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Lookup Tables
\end_layout

\begin_layout Standard
Lookup tables are useful.
 Remember when you were at school and had to find the logarithm of a number?
 You didn't have to calculate it every time it was needed, someone else
 did it for you and put the details in a booklet.
 When writing code it's sometimes useful to use lookup tables rather than
 doing a possibly resource intensive calculation each and every time.
\end_layout

\begin_layout Standard
The rest of this section shows a couple of uses for lookup tables.
 
\end_layout

\begin_layout Section
Bits and Bobs
\end_layout

\begin_layout Standard
Here's a sequence of numbers, they are all integers:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4,numbers=none"
inline false
status open

\begin_layout Plain Layout

0, 1, 1, 2, 1, 2, 2, 3, 1, 2 ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Q1: Do you know what the next value in the sequence will be?
\end_layout

\begin_layout Standard
Q2: Do you know what the above sequence represents?
\end_layout

\begin_layout Standard
Would it help if I told you that the formula to calculate the value for
 number 'n' in the sequence is given by:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Value(n) = (value(int(n/2)) + (n and 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, to find the value of the number 10, the 11th number in the
 sequence as we start from 0, and which just happens to be the answer to
 Q1 above, we must take value(5) and add on bit 0 of 10.
 Of course, we need then to find the answer to Value(2) and add on bit 0
 of 5 and so on.
 Recursion anyone? This works out as the following sequence of calculations:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Value(10) = (value(5) + (10 and 1)
\end_layout

\begin_layout Plain Layout

Value(5)  = (value(2) + (5 and 1)
\end_layout

\begin_layout Plain Layout

Value(2)  = (value(1) + (2 and 1)
\end_layout

\begin_layout Plain Layout

Value(1)  = (value(0) + (1 and 1)
\end_layout

\begin_layout Plain Layout

Value(0)  = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This gives us, working backwards up the above sequence of calculations:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Value(0)  = 0
\end_layout

\begin_layout Plain Layout

Value(1)  = 0 + 1 = 1
\end_layout

\begin_layout Plain Layout

Value(2)  = 1 + 0 = 1
\end_layout

\begin_layout Plain Layout

Value(5)  = 1 + 1 = 2
\end_layout

\begin_layout Plain Layout

Value(10) = 2 + 0 = 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, the 11th number in the sequence is a 2.
 That answers Q1, Q2 will be answered soon, I promise.
\end_layout

\begin_layout Standard
Assuming you need to know these numbers in a program you happen to be writing
 in assembly language, you could work them out each time.
 The formula does tend to imply recursion is required and the following
 brief section of code will do exactly that.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

; On Entry (to Value routine) : 
\end_layout

\begin_layout Plain Layout

;   D0.B = Required value for 'n'.
 
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; On Exit: 
\end_layout

\begin_layout Plain Layout

;   D1.B = Answer (Value(n)).
 
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout

; All registers are preserved except D1 and D0.
 
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

Start   moveq #10,d0        ; N = 10
\end_layout

\begin_layout Plain Layout

        bsr.s Value         ; Get recursive
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

; Result is now in D1.B.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        moveq #0,d1
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Value   tst.b d0            ; N = 0 yet?
\end_layout

\begin_layout Plain Layout

        bne.s More          ; Not yet
\end_layout

\begin_layout Plain Layout

        moveq #0,d1         ; Yes Value(0) = 0
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

More    move.w d0,-(a7)     ; Save current N
\end_layout

\begin_layout Plain Layout

        lsr.b #1,d0         ; INT(N/2)
\end_layout

\begin_layout Plain Layout

        bsr.s Value         ; Recurse
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

; On return to here, D1.B holds the Value(N/2) result.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        move.w (a7)+,d0     ; Current N again
\end_layout

\begin_layout Plain Layout

        btst #0,d0          ; Anything to add in bit 0?
\end_layout

\begin_layout Plain Layout

        beq.s Done          ; No, even number.
\end_layout

\begin_layout Plain Layout

        addq.b #1,d1        ; Yes, add bit 0 of N
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Done    rts 
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Calculating values with recursion
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, what happens in the above when we use 10 as the required value?
\end_layout

\begin_layout Enumerate
At the label 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 = 10 and the stack contains the return address to just after Start, and
 the return to SuperBasic address.
 The stack looks like this:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is not yet zero, we end up at label 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More
\end_layout

\end_inset

 where we stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

, shift it right to get 5, and call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 again.
 At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

, the stack looks like this:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is not yet zero, we end up at label 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More
\end_layout

\end_inset

 where we stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

, shift it right to get 2, and call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 again.
 At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

, the stack looks like this:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is not yet zero, we end up at label 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More
\end_layout

\end_inset

 where we stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

, shift it right to get 1, and call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 again.
 At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

, the stack looks like this:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is not yet zero, we end up at label 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More
\end_layout

\end_inset

 where we stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

, shift it right to get 0, and call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 again.
 At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

, the stack looks like this: 
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is now zero, so we store zero in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D1
\end_layout

\end_inset

 and return to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

, we unstack 1 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

.
 The stack now looks like:
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is odd, we add 1 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D1
\end_layout

\end_inset

.
 The running total is now 1.
 Then we execute an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTS
\end_layout

\end_inset

 instruction and end up back at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

, we unstack 2 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

.
 The stack now looks like:
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

 As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is even, we don't add 1 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D1
\end_layout

\end_inset

.
 The running total is still 1.
 Then we execute an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTS
\end_layout

\end_inset

 instruction and end up back at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

, we unstack 5 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

.
 The stack now looks like:
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is odd, we add 1 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D1
\end_layout

\end_inset

.
 The running total is now 2.
 Then we execute an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTS
\end_layout

\end_inset

 instruction and end up back at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More+8
\end_layout

\end_inset

, we unstack 10 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

.
 The stack now looks like:
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

SuperBasic
\end_layout

\begin_layout Plain Layout

Start+4
\end_layout

\end_inset

 As 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 is even, we don't add 1 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D1
\end_layout

\end_inset

.
 The running total is still 2.
 Then we execute an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RTS
\end_layout

\end_inset

 instruction and end up back at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Start+4
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
At 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Start+4
\end_layout

\end_inset

 we clear 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0
\end_layout

\end_inset

 and return to SuperBasic.
 The value in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D1
\end_layout

\end_inset

 is 2, which is the correct value for the 11th number in the sequence.
 
\end_layout

\begin_layout Standard
The test code above is fine if you only need one or two values, but if your
 code needs lots, then a lookup table would be a good trade off between
 memory usage - you need extra space for the table - and CPU resources -
 if you have to do lots of calculations each time.
 The following code sets up a lookup table for all values from 0 to 255
 - so that's a good reason for having a single byte for each value.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

; Lookup Table initialisation.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; Register Usage:
\end_layout

\begin_layout Plain Layout

;	D0.B = 'N' counter (0 - 255).
\end_layout

\begin_layout Plain Layout

;	D2.B = INT(n/2), value(N).
\end_layout

\begin_layout Plain Layout

;	A2.L = Pointer to start of lookup table.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Entry   bra.s Start         ; Skip the lookup table
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Lookup  ds.b 256  		  ; Lookup table
\end_layout

\begin_layout Plain Layout

  	  
\end_layout

\begin_layout Plain Layout

Start   moveq #0,d0         ; Value(0)
\end_layout

\begin_layout Plain Layout

        lea Lookup,a2       ; Guess!
\end_layout

\begin_layout Plain Layout

        move.b d0,(a2)      ; Save value(0) in table
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Loop    addq.b #1,d0        ; Next 'n'
\end_layout

\begin_layout Plain Layout

        bvs.s Done          ; Bale out at 256
\end_layout

\begin_layout Plain Layout

        move.w d0,d2        ; Copy 'n' to D2
\end_layout

\begin_layout Plain Layout

        lsr.l #1,d2         ; INT(n/2)
\end_layout

\begin_layout Plain Layout

        move.b (a2,d2.w),d2 ; Value(INT(n/2))
\end_layout

\begin_layout Plain Layout

        btst #0,d0          ; Anything to add?
\end_layout

\begin_layout Plain Layout

        beq.s Store         ; No, just store value(n)
\end_layout

\begin_layout Plain Layout

        addq.b #1,d2        ; Yes, add bit 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Store   move.b d2,(a2,d0.w) ; Store Value(n) 
\end_layout

\begin_layout Plain Layout

        bra.s Loop          ; Not done yet
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Done    moveq #0,d0         ; No errors
\end_layout

\begin_layout Plain Layout

        rts
\end_layout

\begin_layout Plain Layout

		
\begin_inset Caption Standard

\begin_layout Plain Layout

Initialising the lookup table
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the program initialises the lookup table during startup, then any time
 it needs to extract a value, it's as simple as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

        move.w #n,d0		; D0 must be 0 - 255
\end_layout

\begin_layout Plain Layout

        lea Lookup,a2
\end_layout

\begin_layout Plain Layout

        move.b (a2,d0.w),d0 ; Value(d0.b)
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Using the lookup table to find a value
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At this point, D0.B holds the result of Value(n).
 Keep in mind that the lookup table only gives values between 0 and 255,
 but D0 is a word in the above for ease of indexing the table.
\end_layout

\begin_layout Standard
So, what's it all about I hear you ask? It's simple, the sequence I gave
 you way back at the beginning is the number of '1' bits in any byte value.
 
\end_layout

\begin_layout Standard
Taking 10 as an example, it is 0000 1010
\begin_inset script subscript

\begin_layout Plain Layout
bin
\end_layout

\end_inset

while 5, half of 10, is 0000 0101
\begin_inset script subscript

\begin_layout Plain Layout
bin
\end_layout

\end_inset

- the same number of bits.
 So, that works for even numbers, how about odd ones? Well, half of 5 is
 2.5 bit as we are rounding down, that's 2.
 Two is 0000 0010
\begin_inset script subscript

\begin_layout Plain Layout
bin
\end_layout

\end_inset

 Doubling 2 gives 4 or 0000 0100
\begin_inset script subscript

\begin_layout Plain Layout
bin
\end_layout

\end_inset

and 5 is just 4 plus 1.
 So, the number of bits in an odd number is still the same as the number
 in half of it, plus bit 0.
 Simples
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As the odd, occasional, passing meerkat has been know to utter!
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Character Characteristics
\end_layout

\begin_layout Standard
Another useful lookup table would be one which, again, covers 256 byte entries.
 However, instead of values, these bytes contain up to 8 bits of 
\begin_inset Quotes els
\end_inset

flag
\begin_inset Quotes ers
\end_inset

 information.
 In the C/C++ programming languages, there are numerous functions (and also,
 macros with the same name) which can be used to determine if a character
 is a digit, upper case, lower case, printable etc.
 This is done with a lookup table of bit flags.
\end_layout

\begin_layout Standard
Each character class (numeric, alphabetic etc) has one or more bits set
 in the table entry to indicate if this character is indeed a digit, upper
 case etc.
 In C68 (look in the header file 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

ctypes.h
\end_layout

\end_inset

) we have a number of bit masks defined, as follows, although I am using
 better names than the C68 code!
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

UPPERCASE   equ 1        ; Bit 0 = A - Z
\end_layout

\begin_layout Plain Layout

LOWERCASE   equ 2        ; Bit 1 = a - z
\end_layout

\begin_layout Plain Layout

DIGIT       equ 4        ; Bit 2 = 0 - 9
\end_layout

\begin_layout Plain Layout

SPACE       equ 8        ; Bit 3 = space, tab, linefeed
\end_layout

\begin_layout Plain Layout

PUNCTUATION equ 16       ; Bit 4 = .,;: etc
\end_layout

\begin_layout Plain Layout

CONTROL     equ 32       ; Bit 5 = Codes < 32 
\end_layout

\begin_layout Plain Layout

BLANK       equ 64       ; Bit 6 = space, tab
\end_layout

\begin_layout Plain Layout

HEXDIGIT    equ 128      ; Bit 7 = A - F, a - f
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Character attribute bit masks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, in the lookup table for the English language, every entry between CODE('A')
 and CODE('Z') will have the UPPERCASE flag, bit 0, set.
 They will also have the HEXDIGIT flag, bit 7, set for 'A' through 'F'.
\end_layout

\begin_layout Standard
Now, I don't know about you, but I really don't fancy typing in 256 entries
 in a table, with the possibility of getting it wrong, somewhere.
 That's a nightmare scenario, so the QL can do it for me (you, on the other
 hand, can simply download the code for this issue and get it for free!)
 I wrote the following, simple, C68 code to generate the file I needed for
 assembly routines, using my own constant values as listed above.
\end_layout

\begin_layout Standard
The following is the listing of the C68 program, 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

characters_c
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> 
\end_layout

\begin_layout Plain Layout

#include <ctype.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]) {
\end_layout

\begin_layout Plain Layout

    int x;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("UPPERCASE    equ 1     ; Bit 0 = A - Z
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("LOWERCASE    equ 2     ; Bit 1 = a - z
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("DIGIT        equ 4     ; Bit 2 = 0 - 9
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("SPACE        equ 8     ; Bit 3 = space tab etc
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("PUNCTUATION  equ 16    ; Bit 4 = .,;: etc
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("CONTROL      equ 32    ; Bit 5 = Various
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("BLANK        equ 64    ; Bit 6 = space tab
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("HEXDIGIT     equ 128   ; Bit 7 = 0 - 9 a - f A - F
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("ALPHABETIC   equ UPPERCASE + LOWERCASE
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("ALPHANUMERIC equ ALPHABETIC + DIGIT
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("PRINTABLE    equ BLANK + PUNCTUATION + ALPHABETIC + DIGIT
\backslash
n");
\end_layout

\begin_layout Plain Layout

    printf("GRAPHIC      equ PUNCTUATION + ALPHABETIC + DIGIT
\backslash
n");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("
\backslash
n
\backslash
nchartab    ");
\end_layout

\begin_layout Plain Layout

    for (x = 0; x < 256; x++) {
\end_layout

\begin_layout Plain Layout

        printf("dc.b 0 ");
\end_layout

\begin_layout Plain Layout

        if (iscntrl(x)) printf("+ CONTROL ");
\end_layout

\begin_layout Plain Layout

        if (isupper(x)) printf("+ UPPERCASE ");
\end_layout

\begin_layout Plain Layout

        if (islower(x)) printf("+ LOWERCASE ");
\end_layout

\begin_layout Plain Layout

        if (isdigit(x)) printf("+ DIGIT ");
\end_layout

\begin_layout Plain Layout

        if (isxdigit(x)) printf("+ HEXDIGIT ");
\end_layout

\begin_layout Plain Layout

        if (ispunct(x)) printf("+ PUNCTUATION ");
\end_layout

\begin_layout Plain Layout

        if (isspace(x)) printf("+ SPACE ");
\end_layout

\begin_layout Plain Layout

        if (x == 9 || x == 32) printf("+ BLANK ");
\end_layout

\begin_layout Plain Layout

        printf("     ; CHR$(%d) = '%c'
\backslash
n           ", x,
\end_layout

\begin_layout Plain Layout

               isprint(x) ? x : '.');
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

C68 utility: characters_c
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code above, compiled to 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

characters_exe
\end_layout

\end_inset

, generates a file that I can use in my assembly code.
 It does it much faster than I can, and more accurately to boot.
 
\end_layout

\begin_layout Standard
Note that the QL doesn't have the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isblank
\end_layout

\end_inset

, so I've hard coded the only two values that that function applies to,
 tab (9) and space (32).
 C68 gives the following character attributes:
\end_layout

\begin_layout Description
UpperCase 65 through 90, 'A' through 'Z';
\end_layout

\begin_layout Description
LowerCase 97 through 122, 'a' through 'z';
\end_layout

\begin_layout Description
Digit 48 through 57, '0' through '9';
\end_layout

\begin_layout Description
Hex
\begin_inset space ~
\end_inset

Digit 48 through 57, 65 through 70, 97 through 102, '0' through '9', 'A'
 through 'F', 'a' through 'f';
\end_layout

\begin_layout Description
WhiteSpace 9 through 13, 32, Tab through Carriage Return, Space;
\end_layout

\begin_layout Description
Blank 9 and 32, Tab and Space;
\end_layout

\begin_layout Description
Control 33 through 47, 58 through 64, 91 through 96, 123 through 126, 128
 through 191.
\end_layout

\begin_layout Description
Puntuation 33 through 47, 58 through 64, 91 through 96, 123 through 126,
 128 through 191;
\end_layout

\begin_layout Standard
The top of the generated file, which I named 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

characters_asm_in
\end_layout

\end_inset

, resembles the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

UPPERCASE    equ 1     ; Bit 0 = A - Z
\end_layout

\begin_layout Plain Layout

LOWERCASE    equ 2     ; Bit 1 = a - z
\end_layout

\begin_layout Plain Layout

DIGIT        equ 4     ; Bit 2 = 0 - 9
\end_layout

\begin_layout Plain Layout

SPACE        equ 8     ; Bit 3 = space tab etc
\end_layout

\begin_layout Plain Layout

PUNCTUATION  equ 16    ; Bit 4 = .,;: etc
\end_layout

\begin_layout Plain Layout

CONTROL      equ 32    ; Bit 5 = Various
\end_layout

\begin_layout Plain Layout

BLANK        equ 64    ; Bit 6 = space tab
\end_layout

\begin_layout Plain Layout

HEXDIGIT     equ 128   ; Bit 7 = 0 - 9 a - f A - F
\end_layout

\begin_layout Plain Layout

ALPHABETIC   equ UPPERCASE + LOWERCASE
\end_layout

\begin_layout Plain Layout

ALPHANUMERIC equ ALPHABETIC + DIGIT
\end_layout

\begin_layout Plain Layout

PRINTABLE    equ BLANK + PUNCTUATION + ALPHABETIC + DIGIT
\end_layout

\begin_layout Plain Layout

GRAPHIC      equ PUNCTUATION + ALPHABETIC + DIGIT
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

chartab    dc.b 0 + CONTROL            ; CHR$(0) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(1) = '.'
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(2) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(3) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(4) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(5) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(6) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(7) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL            ; CHR$(8) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL + SPACE + BLANK ; CHR$(9) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL + SPACE         ; CHR$(10) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL + SPACE         ; CHR$(11) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL + SPACE         ; CHR$(12) = '.' 
\end_layout

\begin_layout Plain Layout

           dc.b 0 + CONTROL + SPACE         ; CHR$(13) = '.'
\end_layout

\begin_layout Plain Layout

           ...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Extract of the generated file 
\lang british

\begin_inset Flex URL
status open

\begin_layout Plain Layout

characters_asm_in
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In assembly code, character attribute functions would look like the following.
 My file is named 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

charAttr_asm_in
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

; All these functions require a character code in D0.B and will
\end_layout

\begin_layout Plain Layout

; return D0 = 0 if the character is invalid, otherwise, D0.B will be 
\end_layout

\begin_layout Plain Layout

; a relatively random non-zer0 value.
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; ENTRY Registers:
\end_layout

\begin_layout Plain Layout

;   D0.B Character code to be tested
\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

; EXIT Registers:
\end_layout

\begin_layout Plain Layout

;   D0.B Zero - Character test failed.
 (Z flag set)
\end_layout

\begin_layout Plain Layout

;        non-zero - Character test passed.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    in characters_asm_in
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

; Given a character code in D0.B, extract the character attributes mask 
\end_layout

\begin_layout Plain Layout

; from chartab to D0.B.
\end_layout

\begin_layout Plain Layout

; Mask the attributes with the desired mask to get the validation result.
\end_layout

\begin_layout Plain Layout

; Return the result in D0.B with Z set to show that the test FAILED.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

; On the stack we have D1.W.
\end_layout

\begin_layout Plain Layout

; D1.B = required mask
\end_layout

\begin_layout Plain Layout

; D0.B = character code
\end_layout

\begin_layout Plain Layout

isanything move.l a2,-(a7)              ; Save the worker
\end_layout

\begin_layout Plain Layout

           ext.w d0                     ; We need this to be word wide
\end_layout

\begin_layout Plain Layout

           move.b (a2,d0.w),d0          ; Character attributes
\end_layout

\begin_layout Plain Layout

           and.b d1,d0                  ; Do attributes match?
\end_layout

\begin_layout Plain Layout

           move.l (a7)+,a2              ; Restore worker
\end_layout

\begin_layout Plain Layout

           move.w (a7)+,d1              ; Restore the other worker
\end_layout

\begin_layout Plain Layout

           tst.w d0                     ; Z = not numeric
\end_layout

\begin_layout Plain Layout

           rts
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

; These just set up the mask we want in D1.W, and jump off to the
\end_layout

\begin_layout Plain Layout

; common code above.
 The unstacking of D1.W and return to caller
\end_layout

\begin_layout Plain Layout

; is done above.
\end_layout

\begin_layout Plain Layout

isdigit    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #DIGIT,d1             ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isalpha    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #ALPHABETIC,d1        ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isalnum    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #ALPHANUMERIC,d1      ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isupper    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #UPPERCASE,d1         ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

islower    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #LOWERCASE,d1         ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isxdigit   move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #HEXDIGIT,d1          ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ispunct    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #PUNCTUATION,d1       ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

iscntrl    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #CONTROL,d1           ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isgraph    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #GRAPHIC,d1           ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isprint    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #PRINTABLE,d1         ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isspace    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #SPACE,d1             ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isblank    move.w d1,-(a7)              ; Save the first worker
\end_layout

\begin_layout Plain Layout

           move.w #BLANK,d1             ; Required attribute mask
\end_layout

\begin_layout Plain Layout

           bra.s isanything             ; Never return here!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Character attributes library - 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

charAttr_asm_in
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
How these work is pretty simple:
\end_layout

\begin_layout Itemize
We enter with the character code to be tested in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0.B
\end_layout

\end_inset

, we save 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D1.W
\end_layout

\end_inset

 on the stack prior to loading 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0.B
\end_layout

\end_inset

 with the required attribute mask that we need for the current test.
\end_layout

\begin_layout Itemize
A branch is then made to the common code which saves 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A2.L
\end_layout

\end_inset

 as we will be using it.
 The character attribute mask is then extracted from the table.
 This mask is appropriate to the value in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0.B
\end_layout

\end_inset

 which we have extended to word sized to index the table.
\end_layout

\begin_layout Itemize
The attribute mask is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AND
\end_layout

\end_inset

ed with the character attribute mask and the result in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0.B
\end_layout

\end_inset

 will be zero if there are no common bits in the two masks - the test has
 failed, or non-zero if at least one pair of common bits matched.
\end_layout

\begin_layout Itemize
The stack is then tidied and we return to the caller with the Z flag set
 to indicate a 
\emph on
failure
\emph default
, unusually, or unset to show that the character code in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0.B
\end_layout

\end_inset

 was a digit, or a letter etc.
\end_layout

\begin_layout Standard
In your code, this can be used as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

          in charAttr_asm_in
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

          ...
\end_layout

\begin_layout Plain Layout

          move.b(a2),d0             ; Get character code from buffer
\end_layout

\begin_layout Plain Layout

          bsr isalpha               ; Is it a letter?
\end_layout

\begin_layout Plain Layout

          beq.s notLetter           ; No, it's not
\end_layout

\begin_layout Plain Layout

          ...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Using the 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

charAttr_asm_in
\end_layout

\end_inset

 routines
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code is useful when writing something like a lexer (part of a compiler,
 assembler etc) or where you are processing text for some reason.
 It can save you having to check that the character in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D0.B
\end_layout

\end_inset

 is less than or equal to 'Z' and greater or equal to 'A' or less than or
 equal to 'z' or greater than or equal to 'a' - and so on.
 (Yes, I know, the 68020 has the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CMP2
\end_layout

\end_inset

 instruction which makes this easier.)
\end_layout

\end_body
\end_document
