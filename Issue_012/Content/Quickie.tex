
\chapter{Quickie Corner}

In this issue's ``Quickie Corner'' I shall take a brief look at program structure. What I mean by this is how to set up the various constructs much loved in structured programming. Plus some other hopefully useful stuff as well. I won't be showing any fully executable code, just the basics.

It's all very well, in SuperBASIC and S*BASIC\footnote{Henceforth referred to as simply S*BASIC.}, having stuff like \texttt{REPeat} \ldots \texttt{END REPeat} or \texttt{IF \ldots ELSE \ldots END IF}, for example, but how do we do this in Assembly Language? 

Some of what we will discuss is hopefully familiar from S*BASIC, but other constructs may not be. Worry not!

Read on.

\section{Repeat Loops}

The simplest of all the looping constructs. You have a loop start and a loop end. Between the two is the loop body, which is where all the work you wish to carry out repeatedly is located. The loop end simply passes program control back to the beginning of the loop.

\begin{lstlisting}[caption={Repeat loops in Assembly Code},label={lis: Repeat loop}]
loopStart
    ; Do loop body code here.

loopEnd
    bra loopStart
\end{lstlisting}

Of course Listing \ref{lis: Repeat loop} is an infinite loop; there is no ``get out'' clause, so once it starts it will continue until power is removed or the world ends! This sort of loop is acceptable under certain circumstances, but normally, users need an opportunity to finish things off nicely. Listings \ref{lis: Repeat loop with exit} and \ref{lis: Repeat loop with alternative exit} should improve things by offering an exit clause. I'm assuming that \register{D0} is zero if wish to exit. Other exit conditions are available!

\begin{lstlisting}[caption={Repeat loops with exit in Assembly Code},label={lis: Repeat loop with exit}]
loopStart
    ; Do loop body code here.
    
loopEnd
    ; Test for exit condition and ...
    ; continue looping until D0 = 0.
    tst.l d0   
    brne loopStart
    
loopDone
    ; Continue onwards from here.
\end{lstlisting}

\begin{lstlisting}[caption={Repeat loops with alternative exit in Assembly Code},label={lis: Repeat loop with alternative exit}]
loopStart
    ; Do loop body code here.

loopEnd
    ; Test for exit condition and ...
    ; continue looping until D0 = 0.
    tst.l d0
    breq loopDone

    ; It appears we are not yet done.
    bra loopStart

loopDone
    ; Continue onwards from here.
\end{lstlisting}

Obviously, Listing \ref{lis: Repeat loop with exit} is the better option as it is slightly shorter, however, there may be code where it is not the better option. It all depends.

The test for the exit condition can come anywhere in the loop body. You can test at the start, at the end, or part way through---it all depends of what the code is doing.

\subsection{Beware of EOF}

It is common in S*BASIC to have a \texttt{REPeat} loop to read a file, and to exit the loop and close the file when EOF is detected. Something like this:

\begin{lstlisting}
1000 OPEN #3,inputFile$
1010 REPeat loop
1020   IF EOF{#3} THEN EXIT loop: END IF
1030   REMark Do stuff here with file contents.
2000 END REP loop
2010 CLOSE #3
\end{lstlisting}

In S*BASIC, you will have read all the contents of the file before EOF is detected. Even if the ``records'' in the file are different lengths, you will read every single one of them before EOF is raised.

In Assembly language, it is different. When you read the last ``record'' from the file, EOF is raised, in \register{D0} at that point. If you were to write the loop in the same style as for S*BASIC, you would detect the EOF in \register{D0} and exit the loop \emph{before} processing the final ``record''.

You would need to write the code to test for EOF after reading from the file, after processing the data, but before skipping back to the top of the loop. This means preserving \register{D0} and/or setting a flag somewhere in your program to indicate that EOF is detected but I'm processing the final chunk of data. Something similar to Listing \ref{lis: Repeat loop with EOF exit} where I'm cheating and using various \texttt{bsr} calls to functions that do the work, although they are not shown.

\begin{lstlisting}[caption={Repeat loops with EOF exit in Assembly Code},label={lis: Repeat loop with EOF exit}]
    
errorEOF equ 10

start
    ; Open the input file. Handle any errors
    ; and exit the job/code if necessary.
    bsr openFile			; Handles errors.

readLoop
    ; Read input file.
    bsr readInputFile		; Errors in D0.
    
    ; Copy error code.
    move.l d0,d7

    ; If no errors, go to processData.
    breq processData
    
    ; If EOF, go to processData.
    cmpi.l #errorEOF,d0
    breq processData
    
handleErrors
    ; Handle the non-EOF errors here and
    ; exit the job/code as necessary.
    ...

processData
    ; Process each record.
    bsr processInputData	; Handles errors

endLoop
    ; Test for EOF again.
    cmpi.l #errorEOF,d7
    brne readLoop

exitLoop
    ; Close file.    
    bsr closeInputFile		; Never errors!
\end{lstlisting}

Here we have a bit of messing about as we need to correctly process the remaining data when we receive the EOF error on the read, but we need to handle any other read errors accordingly. After the read, if there are no errors, or if the error is EOF, we end up at \asmlabel{processData}, otherwise we handle the non-EOF errors and bale out---or otherwise---as appropriate.

After processing the data, we test the copy of the error code from the read of the input file, and if it was not EOF, we loop back to read any more data; otherwise we drop out the bottom of the loop and close the file.

I have to confess that for years I expected the process to be identical in S*BASIC and Assembly and was slightly put out to discover that I had been missing out of some of my data being processed!

There is, of course, duplicated code here. We are making more than one test for EOF which can, occasionally, upset the purists!

%TODO: Test this  concept!


\section{Repeat \ldots\protect Until Loops}

\section{Do \ldots\protect While Loops}

\section{Do \ldots\protect Until Loops}

\section{For Loops}

\section{If \ldots\protect End If}

\section{If \ldots\protect Else \ldots\protect End If}

\section{Exit and Continue}
