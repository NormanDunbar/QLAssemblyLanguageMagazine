
\chapter{Quickie Corner}

In this issue's ``Quickie Corner'' I shall take a brief look at program structure. What I mean by this is how to set up the various constructs much loved in structured programming. Plus some other hopefully useful stuff as well. I won't be showing any fully executable code, just the basics.

It's all very well, in SuperBASIC and S*BASIC\footnote{Henceforth referred to as simply S*BASIC.}, having stuff like \texttt{REPeat} \ldots \texttt{END REPeat} or \texttt{IF \ldots ELSE \ldots END IF}, for example, but how do we do this in Assembly Language? 

Some of what we will discuss is hopefully familiar from S*BASIC, but other constructs may not be. Worry not!

Read on.

\section{Repeat Loop}

The simplest of all the looping constructs. You have a loop start and a loop end. Between the two is the loop body, which is where all the work you wish to carry out repeatedly is located. The loop end simply passes program control back to the beginning of the loop.

\begin{lstlisting}[caption={Repeat loops in Assembly Code},label={lis: Repeat loop}]
loopStart
    ; Do loop body code here.
    ...

loopEnd
    bra loopStart
\end{lstlisting}

Of course Listing \ref{lis: Repeat loop} is an infinite loop; there is no ``get out'' clause, so once it starts it will continue until power is removed or the world ends! This sort of loop is acceptable under certain circumstances, but normally, users need an opportunity to finish things off nicely. Listings \ref{lis: Repeat loop with exit} and \ref{lis: Repeat loop with alternative exit} should improve things by offering an exit clause. I'm assuming that \register{D0} is zero if wish to exit. Other exit conditions are available!

\begin{lstlisting}[caption={Repeat loops with exit in Assembly Code},label={lis: Repeat loop with exit}]
loopStart
    ; Do loop body code here.
    ...
    
loopEnd
    ; Test for exit condition and ...
    ; continue looping until D0 = 0.
    tst.l d0   
    bne loopStart
    
loopDone
    ; Continue onwards from here.
    ...
\end{lstlisting}

\begin{lstlisting}[caption={Repeat loops with alternative exit in Assembly Code},label={lis: Repeat loop with alternative exit}]
loopStart
    ; Do loop body code here.
    ...

loopEnd
    ; Test for exit condition and ...
    ; continue looping until D0 = 0.
    tst.l d0
    beq loopDone

    ; It appears we are not yet done.
    bra loopStart

loopDone
    ; Continue onwards from here.
    ...
\end{lstlisting}

Obviously, Listing \ref{lis: Repeat loop with exit} is the better option as it is slightly shorter, however, there may be code where it is not the better option. It all depends.

The test for the exit condition can come anywhere in the loop body. You can test at the start, at the end, or part way through---it all depends of what the code is doing.

\subsection{Beware of EOF}

It is common in S*BASIC to have a \texttt{REPeat} loop to read a file, and to exit the loop and close the file when EOF is detected. Something like this:

\begin{lstlisting}
1000 OPEN #3,inputFile$
1010 REPeat loop
1020   IF EOF{#3} THEN EXIT loop: END IF
1030   REMark Do stuff here with file contents.
2000 END REP loop
2010 CLOSE #3
\end{lstlisting}

In S*BASIC, you will have read all the contents of the file before EOF is detected. Even if the ``records'' in the file are different lengths, you will read every single one of them before EOF is raised.

In Assembly language, it is different. When you read the last ``record'' from the file, EOF is raised, in \register{D0} at that point. If you were to write the loop in the same style as for S*BASIC, you would detect the EOF in \register{D0} and exit the loop \emph{before} processing the final ``record''.

You would need to write the code to test for EOF after reading from the file, after processing the data, but before skipping back to the top of the loop. This means preserving \register{D0} and/or setting a flag somewhere in your program to indicate that EOF is detected but I'm processing the final chunk of data. Something similar to Listing \ref{lis: Repeat loop with EOF exit} where I'm cheating and using various \texttt{bsr} calls to functions that do the work, although they are not shown.

\begin{lstlisting}[caption={Repeat loops with EOF exit in Assembly Code},label={lis: Repeat loop with EOF exit}]
    
errorEOF equ 10

start
    ; Open the input file. Handle any errors
    ; and exit the job/code if necessary.
    bsr openFile            ; Handles errors.

readLoop
    ; Read input file.
    bsr readInputFile       ; Errors in D0.
    
    ; Copy error code.
    move.l d0,d7

    ; If no errors, go to processData.
    beq processData
    
    ; If EOF, go to processData.
    cmpi.l #errorEOF,d0
    beq processData
    
handleErrors
    ; Handle the non-EOF errors here and
    ; exit the job/code as necessary.
    ...

processData
    ; Process each record.
    bsr processInputData    ; Handles errors

endLoop
    ; Test for EOF again.
    cmpi.l #errorEOF,d7
    bne readLoop

exitLoop
    ; Close file.    
    bsr closeInputFile      ; Never errors!
\end{lstlisting}

Here we have a bit of messing about as we need to correctly process the remaining data when we receive the EOF error on the read, but we need to handle any other read errors accordingly. After the read, if there are no errors, or if the error is EOF, we end up at \asmlabel{processData}, otherwise we handle the non-EOF errors and bale out---or otherwise---as appropriate.

After processing the data, we test the copy of the error code from the read of the input file, and if it was not EOF, we loop back to read any more data; otherwise we drop out the bottom of the loop and close the file.

I have to confess that for years I expected the process to be identical in S*BASIC and Assembly and was slightly put out to discover that I had been missing out of some of my data being processed!

There is, of course, duplicated code here. We are making more than one test for EOF which can, occasionally, upset the purists!

%TODO: Test this  concept!


\section{Repeat \ldots\protect Until Loop}\label{section: repeat until loops}

This is not a structure available on the QL, but it is available in other languages, so might be useful to know about. The body of the loop will be executed at least once as the condition test is at the bottom of the loop. Had the condition test been at the top of the loop, it would have been a \nameref{section: while loops} as discussed in Section \ref{section: while loops}.

Listing \ref{lst:Repeat until loop} shows a minimal example where we test \register{D0} and it it is zero, we don't wish to execute the loop body---effectively, \texttt{Repeat until D0 = 0}.

\begin{lstlisting}[caption={Repeat until loop},label={lst:Repeat until loop}]
repeatLoop
    ; Do loop body code here
    ...
    
until
    ; Do condition test last.
    tst.l d0
    brne repeatLoop
    
    ; Continue from here.
    ...
\end{lstlisting}

You will note that the test of \register{D0} is negated in order to keep looping around. 

This construct is also known as the \texttt{Do \ldots Until loop}.

\section{While \ldots\protect End While Loop}\label{section: while loops}

This is another structure that isn't available on the QL, but is in other languages. It is similar to the \nameref{section: repeat until loops} discussed in Section \ref{section: repeat until loops} but with the condition test at the top of the loop rather than at the end. As the test is carried out at the top of the loop, the loop body may not be executed if the condition is true on entry to the loop.

Listing \ref{lst:while loop} shows a minimal example of this structure---effectively, \texttt{While D0 = 0}.

\begin{lstlisting}[caption={While loop},label={lst:while loop}]
whileLoop
    ; Do condition test first.
    tst.l d0
    brne exitWhile

    ; Do loop body code here
    ...
    
endWhile
    bra whileLoop

exitWhile
    ; Continue from here.
    ...
\end{lstlisting}

You will, hopefully, note that the condition has again been reversed, we loop back to \asmlabel{whileLoop} if \register{D0} is not equal to zero

\section{For \ldots\protect End For Loop}

texttt{FOR} loops are available on the QL. In Assembly Language we can count up or down, as we can in S*BASIC, but the CPU in the QL, and emulators, has a looping instruction---\opcode{dbra} also known as \opcode{dbf}---Decrement  and branch until false. False in this case being the value -1.

Counting upwards can't use that instruction though. Listing \ref{lst: for loop counting upwards} shows a small example of a FOR loop in Assembly. The condition to determine the end of the loop is at the top of the loop. This example is effectively \texttt{FOR d0 = 0 TO 10 STEP 1 \ldots{} END FOR}.

\begin{lstlisting}[caption={For loop - counting upwards},label={lst: for loop counting upwards}]
forLoop
    clr.b d0                ; For do = 0 ...
    
nextFor
    cmpi.b #10,d0           ; To 10 ...
    beq exitFor
    
    ; Do loop body code here.
    ...

endFor
    addq.b #1,d0            ; ... Step 1
    bra nextFor

exitFor
    ; Continue from here
    ...
\end{lstlisting}

Counting downwards, of course, can make use of \opcode{dbra} as Listing \ref{lst: for loop counting downwards} shows. This example is effectively \texttt{FOR d0 = 10 TO 0 step -1 \ldots{} END FOR} but uses values from 9 down to -1.

\begin{lstlisting}[caption={For loop - counting downwards},label={lst: for loop counting downwards}]
forLoop
    moveq.b #10-1,d0        ; For d0 = 10 ...
    
nextFor
    tst.b,d0                ; To 0 ...
    beq exitFor
    
    ; Do loop body code here.
    ...
    
endFor
    dbra d0,nextFor         ; Step -1
    
exitFor
    ; Continue from here
    ...
\end{lstlisting}

In Assembly, it is just as simple to use the actual values from 10 to 1 in the register but the \opcode{dbra} instruction wouldn't then be possible as that instruction, as we know, terminates the loop when the register value is -1 as opposed to zero.

\section{For \ldots\protect Next \ldots\protect End For Loop}

Sometimes, in a \texttt{FOR} statement, we want to skip one or more values in the loop. In those cases we make a test and if true, we call \texttt{NEXT} in our loop body. Listing \ref{lst: for loop with next} shows an example where we execute \texttt{NEXT} if the value in \register{D0} is 7.

\begin{lstlisting}[caption={For loop with next clause},label={lst: for loop with next}]
forLoop
    clr.b d0                ; For do = 0 ...
    
nextFor
    cmpi.b #10,d0           ; To 10 ...
    beq exitFor
    
    cmpi.b #7,d0            ; Is D0 = 7? If so ...
    bra nextFor             ; ... NEXT.
    
    ; Do loop body code here.
    ...
    
endFor
    addq.b #1,d0            ; ... Step 1
    bra nextFor
    
 exitFor
    ; Continue from here
    ...
\end{lstlisting}

\section{If \ldots\protect End If}

\section{If \ldots\protect Else \ldots\protect End If}

\section{Exit and Next}

You've seen \texttt{exit} already. Based on some condition or other, we \texttt{exit} the construct by jumping to just past the end of it; or we jump back to the beginning for \texttt{next}. Listing \ref{lst: exit and next examples} shows simple examples of each.

\begin{lstlisting}[caption={Exit and Next examples},label={lst: exit and next examples}]
loopStart
    ; Do some loop body stuff.
    ...
    
    ; Do a `next loop' if D0 = 0 at this point.
    tst.l d0                ; Is D0 = 0?
    beq loopStart           ; If so, next loop
    
    ; Do more loop body stuff.
    ...
    
    ; Do an `exit loop' if D7 = 0 at this point.
    tst.l d7                ; Is D7 = 0?
    beq loopExit            ; If so, exit loop  
    
loopEnd
    bra loopStart           ; Let's go round again!
    
loopExit
    ; Rest of code ....
    ...
\end{lstlisting}
